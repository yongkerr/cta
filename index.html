<!DOCTYPE html>
<html lang="ko">
<head>
<!-- Parse SDK 추가 -->

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>세무사 시험 문제풀이 시스템</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- ========================================
         01. CSS 스타일 정의 섹션 시작
         ======================================== -->
    <style>
        /* ===== 01-1. 폰트 정의 (DSEG7, digital-7-mono-italic) 시작 ===== */

@font-face {
    font-family: 'digital-7-mono-italic'; 
    /* 01-1-1. 저장소 루트에 있는 폰트 파일을 직접 불러오는 방식 */
    src: url('digital-7-mono-italic.ttf') format('truetype');
    font-weight: normal;
    font-style: normal;
}
        
        @font-face {
            font-family: 'DSEG7';
            src: url('https://cdn.jsdelivr.net/gh/keshikan/DSEG@master/fonts/DSEG7-Classic/DSEG7Classic-Bold.woff2') format('woff2'),
                 url('https://cdn.jsdelivr.net/gh/keshikan/DSEG@master/fonts/DSEG7-Classic/DSEG7Classic-Bold.woff') format('woff');
            font-weight: bold;
            font-style: normal;
        }


        /* ===== 01-1. 폰트 정의 (DSEG7, digital-7-mono-italic) 끝 ===== */

        /* ===== 01-2. 전역 리셋 및 기본 설정 시작 ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f8f9fa;
            height: 100vh;
            overflow: hidden;
            color: #2c3e50;
        }
        
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        html, body {
    touch-action: manipulation; /* 01-2-10. 더블탭/핀치 확대 방지 */
    overscroll-behavior-y: contain; /* 01-2-11. 위아래 스크롤 튐 방지 */
}
* {
    -webkit-tap-highlight-color: transparent; /* 01-2-12. 탭 하이라이트 제거 */
}

        /* ===== 01-2. 전역 리셋 및 기본 설정 끝 ===== */
        
        /* ========================================
             (수정) 01-3. 통합 헤더 스타일 시작
             ======================================== */
        .unified-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            height: 35px;
            background: #ffffff;
            border-bottom: 1px solid #e9ecef;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            flex-shrink: 0; /* 헤더 높이가 줄어들지 않도록 고정 */
            z-index: 200;
        }

        .header-left, .header-center, .header-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .header-left { flex: 1; justify-content: flex-start; }
        .header-center { flex: 1.5; justify-content: center; }
        .header-right { flex: 1; justify-content: flex-end; }

        .header-btn {
            background: none;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        .header-btn:hover { background-color: #f1f3f4; }
        
        .breadcrumb {
            font-size: 14px;
            color: #6c757d;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .breadcrumb .current { font-weight: 500; color: #343a40; }

        .tab-btn {
            background: none;
            border: none;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 500;
            color: #868e96;
            border-radius: 6px;
            transition: all 0.2s;
        }
        .tab-btn.active {
            color: #212529;
            background-color: #e9ecef;
        }
        .tab-btn:hover:not(.active) {
            background-color: #f8f9fa;
        }

        .timer-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .timer-display {
            font-family: 'digital-7-mono-italic', 'Orbitron', monospace;
            font-size: 16px;
            background: #f1f3f4;
            padding: 6px 10px;
            border-radius: 4px;
            min-width: 80px;
            text-align: center;
        }
        .timer-controls { display: flex; gap: 2px; }
        .timer-btn {
            background: none;
            border: 1px solid #ced4da;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }
        .timer-btn:hover { background-color: #e9ecef; }
        /* ========================================
             (수정) 01-3. 통합 헤더 스타일 끝
             ======================================== */

        
/* ===== 01-5. 메인 콘텐츠 영역 스타일 시작 ===== */
.main-content {
    flex: 1;
    position: relative;
    overflow: auto; /* 스크롤 추가 */
    height: calc(100vh - 120px); /* 네비게이션 바 높이 제외 */
}

.question-container {
    flex: 1; /* (수정) 이 영역이 부모의 남은 공간을 모두 차지하도록 설정 */
    margin-bottom: 20px;
}

#options-container {
    overflow-y: auto; /* 선택지 영역에도 스크롤 추가 */
    padding-right: 10px; /* 스크롤바 여백 */
    flex: 1; /* (추가) 부모(.question-container)의 남은 공간을 모두 채움 */
    display: flex; /* (추가) 내부의 이전/다음 버튼을 바닥에 붙이기 위해 플렉스 컨테이너로 설정 */
    flex-direction: column; /* (추가) 내부 요소들을 세로로 배치 */
}

/* ===== 01-5. 메인 콘텐츠 영역 스타일 끝 ===== */

        
        /* ===== 01-6. 사이드바 네비게이션 스타일 시작 ===== */
        .sidebar {
            position: fixed;
            left: -350px;
            top: 0;
            width: 350px;
            height: 100vh;
            background: white;
            border-right: 1px solid #e9ecef;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            transition: left 0.3s ease;
            z-index: 1000;
            overflow-y: auto;
        }
        
        .sidebar.open {
            left: 0;
        }
        
        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
            background: #f8f9fa;
        }
        
        .sidebar-title {
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .menu-section {
            padding: 15px 0;
            border-bottom: 1px solid #f1f3f4;
        }
        
        .menu-section-title {
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 600;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .menu-item {
            padding: 12px 20px;
            cursor: pointer;
            transition: background 0.2s;
            border-left: 3px solid transparent;
        }
        
        .menu-item:hover {
            background: #f8f9fa;
            border-left-color: #007bff;
        }
        
        .menu-item.active {
            background: #e3f2fd;
            border-left-color: #007bff;
            color: #1976d2;
        }
        
        .menu-item-title {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 2px;
        }
        
        .menu-item-desc {
            font-size: 12px;
            color: #6c757d;
        }
        
        .submenu {
            padding-left: 20px;
            background: #fafafa;
            display: none;
        }
        
        .submenu.show {
            display: block;
        }
        
        .submenu-item {
            padding: 8px 20px;
            cursor: pointer;
            font-size: 13px;
            color: #495057;
            transition: all 0.2s;
        }
        
        .submenu-item:hover {
            background: #e9ecef;
            color: #007bff;
        }
        /* ===== 01-6. 사이드바 네비게이션 스타일 끝 ===== */
        
        /* ===== 01-7. 오버레이 스타일 시작 ===== */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
            display: none;
        }
        
        .overlay.show {
            display: block;
        }
        /* ===== 01-7. 오버레이 스타일 끝 ===== */
        
        /* ===== 01-8. 문제풀이 화면 레이아웃 스타일 시작 ===== */
.quiz-layout {
    display: flex;
    height: 100%;
    gap: 4px;
    padding: 8px;
}

.calculator-section {
    flex: none;
    width: 450px;
    min-width: 340px;
    max-width: 540px;
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    border: 1px solid #e9ecef;
    display: flex;
    flex-direction: column;
    
    /* ▼▼▼ (추가) 계산기 위치 고정을 위한 코드 ▼▼▼ */
    position: sticky; /* 스크롤 시 달라붙는 효과 */
    top: 8px;         /* 상단에서 8px 떨어진 위치에 고정 */
        /* ▲▲▲ (추가) 계산기 위치 고정을 위한 코드 ▲▲▲ */
}
/* ===== 01-8. 문제풀이 화면 레이아웃 스타일 끝 ===== */

/* (최종) 01-8-1. 문제 영역 스타일 (통합 최종본) */
.quiz-section {
    flex: 1; 
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    border: 1px solid #e9ecef;
    display: flex;
    flex-direction: column;
    position: relative;
    
    /* ▼ 스크롤 문제 해결을 위한 핵심 속성 ▼ */
    overflow-y: auto; 
    min-height: 0; 
    -webkit-overflow-scrolling: touch; 
    
    /* ▼ 스크롤바 디자인을 위한 속성 ▼ */
    scrollbar-width: thin; /* Firefox */
    scrollbar-color: #ced4da #f1f3f4; /* Firefox */
}

/* 스크롤바 웹킷 브라우저(크롬, 사파리, 아이패드)용 스타일 */
.quiz-section::-webkit-scrollbar,
.workspace-section-new::-webkit-scrollbar {
    width: 12px; /* 스크롤바 너비 */
}
.quiz-section::-webkit-scrollbar-track,
.workspace-section-new::-webkit-scrollbar-track {
    background: #f1f3f4; /* 트랙 배경색 */
    border-radius: 6px;
}
.quiz-section::-webkit-scrollbar-thumb,
.workspace-section-new::-webkit-scrollbar-thumb {
    background: #ced4da; /* 스크롤바 막대 색상 */
    border-radius: 6px;
    border: 3px solid #f1f3f4; /* 트랙과 여백을 줘서 떠있는 효과 */
}
.quiz-section::-webkit-scrollbar-thumb:hover,
.workspace-section-new::-webkit-scrollbar-thumb:hover {
    background: #adb5bd;
}
        
        /* ===== 01-9. 계산기 컨테이너 스타일 (CASIO JS-40B 디자인) 시작 ===== */
        .calculator-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #b0aeaf;
            border-radius: 8px;
            padding: 15px;
            border: 2px solid #1a1a1a;
        }
        
        .calc-brand {
            color: white;
            font-size: 14px;
            font-weight: bold;
            text-align: left;
            margin-bottom: 10px;
            letter-spacing: 2px;
        }
        /* ===== 01-9. 계산기 컨테이너 스타일 (CASIO JS-40B 디자인) 끝 ===== */
        
        /* ===== 01-10. 계산기 디스플레이 (14자리 지원, DSEG 폰트) 시작 ===== */
        .calculator-display {
            background: #7b8a77;
            color: #1f1d1d;
            padding: 10px 5px 5px 5px;
            text-align: right;
            font-size: 32px;
            font-family: 'digital-7-mono-italic', monospace;
            font-weight: bold;
            border-radius: 4px;
            margin-bottom: 5px;
            min-height: 60px;
            display: flex;
            align-items: flex-end;
            justify-content: flex-end;
            border: 2px solid #0a0a0a;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
            position: relative;
            letter-spacing: 1px;
            overflow: visible;
        }
        
        .memory-indicator {
            position: absolute;
            left: 20px;
            top: 8px;
            font-size: 20px;
            font-weight: bold;
            color: #1f1d1d;
            font-family: 'digital-7-mono-italic', 'Orbitron', monospace;
            pointer-events: none;
        }
        
        .display-value {
            text-align: right;
            font-family: 'digital-7-mono-italic', 'Orbitron', monospace;
            font-weight: bold;
            font-size: 36.5px;
            width: 100%;
            overflow: visible;
            direction: ltr;
            unicode-bidi: plaintext;
            white-space: nowrap;
            line-height: 1;
            padding-bottom: 0px;
        }
        /* ===== 01-10. 계산기 디스플레이 (14자리 지원, DSEG 폰트) 끝 ===== */
        
        /* ===== 01-11. 계산기 버튼 그리드 (5x6 레이아웃) 시작 ===== */
        .calculator-buttons {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(6, 1fr);
            gap: 4px;
            flex: 1;
            max-width: 100%;
        }
        
        .calc-btn {
            border: 1px solid #444;
            border-radius: 4px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.1s;
            min-height: 40px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
        }
        
        .calc-btn:active {
            transform: scale(0.95);
            box-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        /* 01-11-1. 숫자 버튼 스타일 (검은색) 시작 */
        .calc-btn.number, .calc-btn.number:hover {
            background: #000000 !important;
            color: #ffffff !important;
            border-color: #444444 !important;
        }
        
        .calc-btn.number:hover {
            background: #222222 !important;
        }
        /* 01-11-1. 숫자 버튼 스타일 (검은색) 끝 */
        
        /* 01-11-2. 연산자, 기능, 메모리 버튼 스타일 (회색) 시작 */
        .calc-btn:not(.number),
        .calc-btn.operator, .calc-btn.operator:hover, 
        .calc-btn.function, .calc-btn.function:hover, 
        .calc-btn.equals, .calc-btn.equals:hover,
        .calc-btn.memory, .calc-btn.memory:hover {
            background: #4a4a4a !important;
            color: #ffffff !important;
            border-color: #333333 !important;
        }
        
        .calc-btn.memory {
            color: #000000 !important;
        }
        /* 01-11-2. 연산자, 기능, 메모리 버튼 스타일 (회색) 끝 */
        
        /* 01-11-3. C, AC 버튼 특별 색상 (주황색) 시작 */
        .calc-btn.function[onclick*='clearEntry'], 
        .calc-btn.function[onclick*='clearAll'] {
            color: #ff6600 !important;
        }
        /* 01-11-3. C, AC 버튼 특별 색상 (주황색) 끝 */
        
        /* 01-11-4. + 버튼 세로 2칸 차지 시작 */
        .calc-btn.plus-tall {
            grid-row: span 2;
            background: #4a4a4a !important;
            color: #ffffff !important;
            border-color: #333333 !important;
        }
        
        .calc-btn.plus-tall:hover {
            background: #3a3a3a !important;
        }
        /* 01-11-4. + 버튼 세로 2칸 차지 끝 */
        /* ===== 01-11. 계산기 버튼 그리드 (5x6 레이아웃) 끝 ===== */

        /* ===== 01-12. 계산기록 영역 스타일 시작 ===== */
        .calculation-history {
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #dee2e6;
            max-height: 100px;
        }

        .history-title {
            font-size: 12px;
            font-weight: 600;
            color: #6c757d;
            margin-bottom: 6px;
            text-transform: uppercase;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-values {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            max-height: 50px;
            overflow-y: auto;
            margin-bottom: 6px;
        }

        .history-value {
            font-family: 'digital-7-mono-italic', monospace;
            font-size: 12px;
            color: #495057;
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
            transition: background 0.2s;
            border: 1px solid #dee2e6;
        }

        .history-value:hover {
            background: #007bff;
            color: white;
        }

        .clear-history-btn {
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 10px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .clear-history-btn:hover {
            background: #5a6268;
        }
        /* ===== 01-12. 계산기록 영역 스타일 끝 ===== */
                
        /* ===== 01-15. 퀴즈 영역 스타일 시작 ===== */
        .quiz-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            font-weight: 500;
            color: #495057;
            font-size: 14px;
        }
        
        .question-container {
            flex: 1;
            margin-bottom: 20px;
        }
        
        #question-text {
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 20px;
            color: #2c3e50;
        }
        /* ===== 01-15. 퀴즈 영역 스타일 끝 ===== */
        
        /* ===== 01-16. 반응형 미디어 쿼리 시작 ===== */
        @media (max-width: 768px) {
            .quiz-layout {
                flex-direction: column;
            }
        }
        /* ===== 01-16. 반응형 미디어 쿼리 끝 ===== */

/* ===== 01-17. 문제 해설 관련 스타일 시작 ===== */
.question-header {
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid #e9ecef;
}

.question-meta {
    font-size: 12px;
    color: #6c757d;
    background: #f8f9fa;
    padding: 4px 8px;
    border-radius: 4px;
}

.question-content {
    font-size: 16px;
    line-height: 1.6;
    color: #2c3e50;
}

.option-item {
    margin-bottom: 10px;
    padding: 12px;
    border: 1px solid #dee2e6;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s;
}

.option-item:hover {
    background: #f8f9fa;
    border-color: #007bff;
}

.option-number {
    display: inline-block;
    width: 24px;
    height: 24px;
    background: #6c757d;
    color: white;
    border-radius: 50%;
    text-align: center;
    line-height: 24px;
    font-size: 12px;
    font-weight: bold;
    margin-right: 10px;
}

.explanation-item {
    margin-bottom: 15px;
    padding: 15px;
    border-radius: 8px;
    border-left: 4px solid #6c757d;
}

.explanation-item.correct {
    background: #d4edda;
    border-left-color: #28a745;
}

.explanation-item.incorrect {
    background: #f8d7da;
    border-left-color: #dc3545;
}

.explanation-item.user-choice {
    box-shadow: 0 0 0 2px #007bff;
}

.option-header {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
}

.option-status {
    margin-left: auto;
    font-weight: bold;
    font-size: 14px;
}

.explanation-text {
    font-size: 14px;
    line-height: 1.5;
    color: #495057;
}

.submit-answer-btn, .next-question-btn {
    background: #007bff;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 16px;
    margin-top: 20px;
    width: 100%;
}

.submit-answer-btn:hover, .next-question-btn:hover {
    background: #0056b3;
}

.result-summary {
    background: #e9ecef;
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 20px;
    text-align: center;
}

.result-summary h4 {
    margin: 0 0 10px 0;
    font-size: 18px;
}

.result-summary p {
    margin: 5px 0;
    font-size: 14px;
}

/* ===== 01-17. 문제 해설 관련 스타일에 추가 ===== */
.explanation-item {
    margin-bottom: 15px;
    padding: 15px;
    border-radius: 8px;
    border-left: 4px solid #6c757d;
    max-height: none; /* 높이 제한 제거 */
    overflow: visible; /* 내용 모두 표시 */
}

.explanation-text {
    font-size: 14px;
    line-height: 1.5;
    color: #495057;
    white-space: pre-wrap; /* 줄바꿈 유지 */
    word-wrap: break-word; /* 긴 단어 줄바꿈 */
}

.detail-navigation {
    position: sticky; /* 네비게이션 고정 */
    bottom: 0;
    background: white;
    padding: 15px 0;
    border-top: 1px solid #e9ecef;
    margin-top: 20px;
}
/* ===== 01-17-1. 참고 사항 스타일 시작 ===== */
.reference-note {
    margin-top: 12px;
    padding: 10px;
    background-color: #f8f9fa;
    border-radius: 4px;
    border-left: 3px solid #6c757d;
    font-size: 13px;
    color: #495057;
    white-space: pre-wrap;
    line-height: 1.6;
}

.reference-note strong {
    font-weight: 600;
    color: #2c3e50;
    display: block;
    margin-bottom: 5px;
}
/* ===== 01-17-1. 참고 사항 스타일 끝 ===== */


/* ===== 01-17. 문제 해설 관련 스타일 끝 ===== */
/* ===== 01-19. 해설 모드 전용 레이아웃 스타일 시작 ===== */
.explanation-mode {
    display: flex;
    height: 100%;
    gap: 20px;
    padding: 20px;
}

.explanation-content {
    flex: 1;
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    border: 1px solid #e9ecef;
    overflow-y: auto;
    max-height: calc(100vh - 140px);
}


/* 동적 해설 칸 크기 조정 */
.explanation-item.short {
    padding: 10px 15px;
    min-height: auto;
}

.explanation-item.medium {
    padding: 15px;
    min-height: auto;
}

.explanation-item.long {
    padding: 20px;
    min-height: auto;
}

/* 문제별 구분선 */
.question-divider {
    border-top: 2px solid #007bff;
    margin: 30px 0 20px 0;
    padding-top: 20px;
}

.question-summary {
    background: #f8f9fa;
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 20px;
    border-left: 4px solid #007bff;
}

.question-result {
    display: inline-block;
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: bold;
    margin-left: 10px;
}

.question-result.correct {
    background: #d4edda;
    color: #155724;
}

.question-result.incorrect {
    background: #f8d7da;
    color: #721c24;
}

.explanation-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 10px;
    border-bottom: 1px solid #e9ecef;
}

.explanation-controls {
    display: flex;
    gap: 10px;
}
/* ===== 01-19. 해설 모드 전용 레이아웃 스타일 끝 ===== */

/* ===== 01-18. 문제풀이 네비게이션 스타일 시작 ===== */
.option-item.selected {
    background: #e3f2fd;
    border-color: #2196f3;
    box-shadow: 0 0 0 2px #2196f3;
}

.question-navigation, .detail-navigation {
    display: flex;
    gap: 10px;
    margin-top: auto; /* (핵심 수정) 컨테이너의 남은 공간을 모두 차지하여 버튼들을 맨 아래로 밀어냄 */
    padding-top: 20px; /* (추가) 버튼과 문제 내용 사이의 여백 확보 */
    justify-content: space-between;
}

.nav-btn {
    background: #6c757d;
    color: white;
    border: none;
    padding: 10px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.2s;
}

.nav-btn:hover:not(:disabled) {
    background: #5a6268;
}

.nav-btn:disabled {
    background: #dee2e6;
    color: #6c757d;
    cursor: not-allowed;
}

.finish-btn {
    background: #28a745 !important;
}

.finish-btn:hover {
    background: #218838 !important;
}

.quiz-results {
    text-align: center;
    padding: 20px;
}

.score-summary {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 20px;
    margin: 20px 0;
}

.score-circle {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100px;
    height: 100px;
    border-radius: 50%;
    background: #e3f2fd;
    border: 3px solid #2196f3;
}

.score-number {
    font-size: 24px;
    font-weight: bold;
    color: #2196f3;
}

.score-total {
    font-size: 14px;
    color: #6c757d;
}

.score-percentage {
    font-size: 36px;
    font-weight: bold;
    color: #2196f3;
}

.score-details {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin: 20px 0;
}

.correct {
    color: #28a745;
    font-weight: bold;
}

.incorrect {
    color: #dc3545;
    font-weight: bold;
}

.result-item {
    margin-bottom: 10px;
    padding: 12px;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s;
    border-left: 4px solid #6c757d;
}

.result-item.correct {
    background: #d4edda;
    border-left-color: #28a745;
}

.result-item.incorrect {
    background: #f8d7da;
    border-left-color: #dc3545;
}

.result-item:hover {
    transform: translateX(5px);
}

.result-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 5px;
}

.question-num {
    font-weight: bold;
}

.result-status {
    font-size: 14px;
    font-weight: bold;
}

.result-info {
    display: flex;
    justify-content: space-between;
    font-size: 12px;
    color: #6c757d;
}

.retry-section {
    display: flex;
    gap: 10px;
    margin-top: 20px;
    justify-content: center;
}

.retry-btn, .review-btn {
    background: #007bff;
    color: white;
    border: none;
    padding: 12px 20px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
}

.retry-btn:hover, .review-btn:hover {
    background: #0056b3;
}

.review-btn {
    background: #ffc107;
    color: #212529;
}

.review-btn:hover {
    background: #e0a800;
}
/* ===== 01-18. 문제풀이 네비게이션 스타일 끝 ===== */

/* ===== 01-20. 참고사항 스타일 시작 ===== */
.general-reference-note {
    margin-top: 20px;
    padding: 15px;
    background-color: #fff3cd;
    border: 1px solid #ffeaa7;
    border-radius: 8px;
    border-left: 4px solid #f39c12;
}

.reference-header {
    font-weight: bold;
    color: #856404;
    margin-bottom: 10px;
    font-size: 14px;
}

.reference-content {
    color: #856404;
    line-height: 1.5;
    font-size: 13px;
}
/* ===== 01-20. 참고사항 스타일 끝 ===== */

/* ===== 01-21. 퀴즈 결과 화면 스타일 (그리드 뷰) 시작 ===== */
.results-mode {
    padding: 20px;
    background-color: #f8f9fa;
    height: 100%;
    overflow-y: auto;
    text-align: center;
}

.results-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
    gap: 10px;
    margin-top: 30px;
    padding: 20px;
    background: white;
    border-radius: 8px;
    border: 1px solid #e9ecef;
}

.result-grid-item {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 50px;
    border-radius: 6px;
    font-weight: bold;
    font-size: 14px;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    border: 1px solid transparent;
}

.result-grid-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

.result-grid-item.correct {
    background: #d4edda;
    color: #155724;
    border-color: #c3e6cb;
}

.result-grid-item.incorrect {
    background: #f8d7da;
    color: #721c24;
    border-color: #f5c6cb;
}
/* ===== 01-21. 퀴즈 결과 화면 스타일 (그리드 뷰) 끝 ===== */

/* ===== 01-23. 주석(Annotation) 및 연습장(Workspace) 스타일 시작 ===== */

/* 01-23-1. 문제 위에 겹쳐지는 투명 필기 캔버스 */
.annotation-canvas {
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    /* (핵심 수정) 오른쪽에서 17px의 공간을 남겨 스크롤바 영역을 물리적으로 확보합니다. */
    right: 17px; 
    /* width와 height는 auto로 설정하여 위/아래/왼쪽/오른쪽 속성에 반응하도록 합니다. */
    width: auto; 
    height: auto;
    z-index: 10;
    cursor: crosshair;
    pointer-events: auto;
    touch-action: none; 
}


/* 01-23-3. 퀴즈 영역과 연습장을 감싸는 세로 컨테이너 */
.main-column {
    display: flex;
    flex-direction: column;
    flex: 2.2; /* 기존 quiz-section과 동일한 너비 비율 */
    gap: 0; /* 분할 바로 간격 제어 */
    min-width: 0; /* flex item의 크기가 줄어들 수 있도록 설정 */
}

/* 01-23-4. 하단 연습장 섹션 */
.workspace-section-new {
    flex-basis: 200px;
    min-height: 50px;
    background: white;
    border-radius: 8px;
    padding: 15px;
    padding-right: 25px; /* (수정) 오른쪽 여백을 늘려 힌트 공간 확보 */
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    border: 1px solid #e9ecef;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    position: relative; /* (추가) ::after 유사 요소를 위한 기준점 */
}

.workspace-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    padding-bottom: 10px;
    border-bottom: 1px solid #e9ecef;
    flex-shrink: 0;
}

.workspace-header h3 {
    font-size: 16px;
    margin: 0;
}

.draw-btn {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    padding: 4px 8px;
    font-size: 12px;
    cursor: pointer;
}

/* 01-23-5. 연습장 캔버스 */
.workspace-canvas {
    width: 100%;
    height: 1000px; /* (핵심 수정) 캔버스의 실제 높이를 1000px로 고정 */
    background: #fdfdfd;
    border: 1px dashed #ccc;
    border-radius: 4px;
    touch-action: none;
}

/* 01-23-6. 크기 조절 바(Resizer) 스타일 */
.resizer-vertical {
    background: #e9ecef;
    cursor: row-resize;
    height: 20px;
    border-top: 1px solid #dee2e6;
    border-bottom: 1px solid #dee2e6;
    position: relative;
    transition: background 0.2s;
}

.resizer-vertical:hover {
    background: #007bff;
}

.resizer-vertical::before {
    content: '•••';
    position: absolute;
    top: -5px;
    left: 50%;
    transform: translateX(-50%);
    color: #6c757d;
    font-size: 16px;
    letter-spacing: 2px;
}

/* 01-23-7. 개별 해설 화면의 연습장 이미지 스타일 */
.workspace-snapshot {
    margin-top: 20px;
    border: 1px solid #ccc;
    border-radius: 4px;
    width: 100%;
}

.workspace-snapshot-header {
    font-weight: bold;
    margin-bottom: 10px;
    font-size: 14px;
}
/* ===== 01-23. 주석(Annotation) 및 연습장(Workspace) 스타일 끝 ===== */

/* (신규) 01-24. 스크롤 가능 영역을 위한 시각적 힌트 스타일 */
.quiz-section::after,
.workspace-section-new::after {
    content: '';
    position: absolute;
    top: 8px;
    right: 8px;
    bottom: 8px;
    width: 6px;
    background-color: #e0e0e0;
    border-radius: 3px;
    opacity: 0.8;
    pointer-events: none; /* 힌트가 클릭되지 않도록 설정 */
}

        /* (신규) 01-25. 이론학습 페이지 스타일 시작 */
        .theory-layout {
            display: none; /* 기본적으로 숨김 */
            height: 100%;
            flex-direction: column;
        }

        .theory-main-content {
            flex: 1;
            padding: 5px;
            overflow: hidden;
            display: flex;           /* 01-25-1. (추가) 자식 요소를 flex로 제어하기 위해 추가 */
            justify-content: center; /* 01-25-2. (추가) 가로 중앙 정렬을 위해 추가 */
            align-items: flex-start;   /* 01-25-3. (수정) 책을 화면 상단에 맞추기 위해 '시작점' 정렬로 변경 */
}

        .theory-book {
    display: flex;
    height: 100%; 
    max-width: 1340px;
    max-height: 1000px;
    margin: auto; /* 자동 중앙 정렬은 유지합니다. */

    /* --- (신규) 스크롤 스냅 적용을 위한 핵심 코드 --- */
    overflow-x: auto; /* 01-25-6. (추가) 내용이 넘칠 때 가로 스크롤이 가능하도록 설정 */
    scroll-snap-type: x mandatory; /* 01-25-7. (추가) 가로 스크롤이 멈출 때 자석처럼 달라붙게 함 */
    gap: 40px; /* 01-25-8. (추가) margin-right 대신 페이지 펼침면 사이의 간격을 설정 */

    /* --- (신규) 스크롤바 숨기기 --- */
    -ms-overflow-style: none; /* 01-25-9. (추가) IE, Edge 용 스크롤바 숨기기 */
    scrollbar-width: none; /* 01-25-10. (추가) Firefox 용 스크롤바 숨기기 */
}
/* 01-25-11. (추가) 크롬, 사파리 등 Webkit 계열용 스크롤바 숨기기 */
.theory-book::-webkit-scrollbar {
    display: none; 
}

        .theory-book:active { cursor: grabbing; }

        .theory-page-spread {
    flex: 0 0 100%; /* 01-25-12. (유지) 펼침면이 부모 너비의 100%를 차지하게 함 */
    display: flex;
    box-shadow: 0 8px 30px rgba(0,0,0,0.12);
    border-radius: 6px;
    scroll-snap-align: center; /* 01-25-13. (추가) 스크롤이 멈출 때 이 요소를 화면 중앙에 맞춤 */
}

    .theory-page {
    flex: 1 0 50%; /* 01-25-15. (수정) 각 페이지가 펼침면의 50%를 정확히 차지하도록 설정 */
    background-color: #fff;
    padding: 15px 20px;
    overflow-y: auto; /* 01-25-16. (수정) 내용이 페이지보다 길 경우에만 스크롤이 생기도록 변경 */
    position: relative;
    box-sizing: border-box; /* 01-25-17. (추가) 패딩을 너비 계산에 포함시켜 레이아웃이 깨지지 않게 함 */
}



        .theory-left-page {
            border-top-left-radius: 6px;
            border-bottom-left-radius: 6px;
        }
        .theory-right-page {
            border-top-right-radius: 6px;
            border-bottom-right-radius: 6px;
            border-left: 1px solid #eee;
        }
        
        .theory-page-number {
            position: absolute;
            bottom: 15px;
            font-size: 12px;
            color: #999;
        }
        .theory-left-page .theory-page-number { left: 40px; }
        .theory-right-page .theory-page-number { right: 40px; }

        .theory-content-wrapper h1, .theory-content-wrapper h2, .theory-content-wrapper h3, .theory-content-wrapper h4  {
    display: block; /* 01-25-19. (수정) 제목이 한 줄을 모두 차지하도록 블록 요소로 변경 */
    line-height: 1.7; /* 01-25-20. (수정) 줄 간격 조정 */
    margin-top: 15px; /* 01-25-21. (추가) 제목 위에 여백을 주어 가독성 향상 */
    margin-bottom: 10px; /* 01-25-22. (추가) 제목 아래에도 여백 추가 */
    padding: 0; /* 01-25-23. (삭제) 배경색을 없애므로 패딩도 초기화 */
    border-radius: 0;
}

        .theory-content-wrapper h1 { background-color: #dad4ff; }
        .theory-content-wrapper h2 { background-color: #b7e5ff; }
        .theory-content-wrapper h3 { background-color: #D6E8DB; }
        .theory-content-wrapper p { margin-top: 12px; line-height: 1.7; color: #333; }
        .theory-content-wrapper table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        .theory-content-wrapper th, .theory-content-wrapper td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        .theory-content-wrapper th { background-color: #f2f2f2; }
        .theory-content-wrapper a { color: #007bff; text-decoration: none; }
        .theory-content-wrapper a:hover { text-decoration: underline; }

/* (신규) 01-25-24. 이론 학습 페이지의 목록(리스트) 스타일 추가 */
.theory-content-wrapper ul, 
.theory-content-wrapper ol { /* (핵심 수정 1) ol 태그도 적용 대상에 추가 */
    padding-left: 28px; /* (핵심 수정 2) 잘림 현상 해결을 위해 들여쓰기 값을 넉넉하게 늘림 */
}
.theory-content-wrapper li {
    line-height: 1.65; 
    margin-bottom: 2px; /* (수정) 항목 간 여백을 조금 더 확보 */
}



        /* ===== 01-25. 이론학습 페이지 스타일 끝 ===== */


        /* ========================================
             (신규) 01-26. 플로팅 목차(TOC) 스타일 시작
             ======================================== */
        .floating-toc {
            position: fixed;
            top: 0;
            right: -320px; /* 기본적으로 화면 밖에 숨겨 둠 */
            width: 300px;
            height: 100%;
            background: #fff;
            border-left: 1px solid #e9ecef;
            box-shadow: -2px 0 10px rgba(0,0,0,0.08);
            z-index: 900;
            display: flex;
            flex-direction: column;
            transition: right 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        .floating-toc.open {
            right: 0; /* open 클래스가 붙으면 화면 안으로 나타남 */
        }

        .floating-toc-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
            flex-shrink: 0;
        }
        .floating-toc-header h3 {
            font-size: 16px;
            margin: 0;
        }
        .floating-toc-header .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #6c757d;
        }

        .floating-toc-list {
            list-style: none;
            padding: 10px 0;
            overflow-y: auto;
            flex-grow: 1;
        }
        .floating-toc-list li a {
            display: block;
            padding: 8px 20px;
            font-size: 14px;
            color: #495057;
            text-decoration: none;
            border-left: 3px solid transparent;
            transition: all 0.2s;
        }
        .floating-toc-list li a:hover {
            background-color: #f8f9fa;
        }
        .floating-toc-list li a.active {
            color: #007bff;
            font-weight: 600;
            background-color: #e3f2fd;
            border-left-color: #007bff;
        }
        .floating-toc-list li a[data-level="h2"] { padding-left: 35px; }
        .floating-toc-list li a[data-level="h3"] { padding-left: 50px; }
        /* ========================================
             (신규) 01-26. 플로팅 목차(TOC) 스타일 끝
             ======================================== */


    </style>

    <!-- =====  iOS 전체화면(PWA) 메타태그 추가 ===== -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="apple-mobile-web-app-title" content="세무사 학습 웹앱">
<!-- =====  iOS 전체화면(PWA) 메타태그 끝 ===== -->



    <!-- ========================================
         01. CSS 스타일 정의 섹션 끝
         ======================================== -->
</head>
<body>
    <div class="app-container">
        <!-- ========================================
             02. 오버레이 및 사이드바 섹션 시작
             ======================================== -->
        
        <!-- 02-1. 사이드바 배경 오버레이 시작 -->
        <div class="overlay" id="overlay" onclick="closeSidebar()"></div>
        <!-- 02-1. 사이드바 배경 오버레이 끝 -->
        
                <!-- ========================================
             02-2. 사이드바 네비게이션 메뉴 (목차 구조) 시작 (수정됨)
             ======================================== -->
        <div class="sidebar" id="sidebar">
            <!-- 02-2-0. 사이드바 헤더 시작 -->
            <div class="sidebar-header">
                <!-- 이 제목은 JavaScript에 의해 동적으로 변경됩니다 -->
                <div class="sidebar-title" id="sidebar-title">📚 문제풀이 목차</div>
            </div>
            <!-- 02-2-0. 사이드바 헤더 끝 -->
            
            <!-- ========================================
                 (신규) 문제풀이 목차 컨테이너 시작
                 ======================================== -->
            <div id="quiz-menu-content">
                <!-- 02-2-1. 1차 시험 메뉴 섹션 시작 -->
                <div class="menu-section">
                    <div class="menu-section-title">📝 1차 시험 문제풀이</div>
                    
                    <!-- 02-2-1-1. 회계학개론 메뉴 시작 -->
                    <div class="menu-item" onclick="toggleSubmenu('accounting')">
                        <div class="menu-item-title"> 회계학개론</div>
                        <div class="menu-item-desc">연도별 및 과목별 문제풀이</div>
                    </div>
                    <div class="submenu" id="accounting-submenu">
                        <div class="submenu-item" onclick="toggleSubmenu('accounting-years')">📅 연도별 기출 ▼</div>
                        <div class="submenu" id="accounting-years-submenu" style="padding-left: 20px; display: none;">
                            <div class="submenu-item" onclick="selectChapter('회계학개론', '2025년기출')">2025년 제62회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('회계학개론', '2024년기출')">2024년 제61회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('회계학개론', '2023년기출')">2023년 제60회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('회계학개론', '2022년기출')">2022년 제59회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('회계학개론', '2021년기출')">2021년 제58회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('회계학개론', '2020년기출')">2020년 제57회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('회계학개론', '2019년기출')">2019년 제56회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('회계학개론', '2018년기출')">2018년 제55회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('회계학개론', '2017년기출')">2017년 제54회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('회계학개론', '2016년기출')">2016년 제53회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('회계학개론', '2015년기출')">2015년 제52회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('회계학개론', '2014년기출')">2014년 제51회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('회계학개론', '2013년기출')">2013년 제50회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('회계학개론', '2012년기출')">2012년 제49회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('회계학개론', '2011년기출')">2011년 제48회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('회계학개론', '2010년기출')">2010년 제47회 기출</div>
                        </div>
                        <div class="submenu-item" onclick="toggleSubmenu('accounting-subjects')">📖 과목별 기출 ▼</div>
                        <div class="submenu" id="accounting-subjects-submenu" style="padding-left: 20px; display: none;">
                            
                            <div class="submenu-item" onclick="toggleSubmenu('financial-chapters')">📖 재무회계 ▼</div>
                            <div class="submenu" id="financial-chapters-submenu" style="padding-left: 40px; display: none;">
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제1장')">제1장 재무제표 표시</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제2장')">제2장 공정가치 측정과 현재가치 평가</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제3장')">제3장 수익</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제4장')">제4장 건설계약</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제5장')">제5장 재고자산과 농림어업</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제6장')">제6장 유형자산(Ⅰ): 최초인식과 후속측정</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제7장')">제7장 유형자산(Ⅱ): 취득형태별 원가</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제8장')">제8장 차입원가</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제9장')">제9장 무형자산</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제10장')">제10장 금융부채</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제11장')">제11장 충당부채와 보고기간후사건</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제12장')">제12장 자본</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제13장')">제13장 재무보고를 위한 개념체계</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제14장')">제14장 금융자산(Ⅰ): 채무상품과 지분상품</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제15장')">제15장 금융자산(Ⅱ): 현금과 매출채권</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제16장')">제16장 복합금융상품</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제17장')">제17장 종업원급여</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제18장')">제18장 주식기준보상</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제19장')">제19장 리스회계</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제20장')">제20장 투자부동산과 매각예정비유동자산</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제21장')">제21장 법인세회계</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제22장')">제22장 회계변경과 오류수정</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제23장')">제23장 주당이익</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제24장')">제24장 현금흐름표와 중간재무보고</div>
                                <div class="submenu-item" onclick="selectChapter('재무회계', '제25장')">제25장 고급회계</div>
                            </div>
                            <div class="submenu-item" onclick="toggleSubmenu('cost-chapters')">📖 원가관리회계 ▼</div>
                            <div class="submenu" id="cost-chapters-submenu" style="padding-left: 40px; display: none;">
                                <div class="submenu-item" onclick="selectChapter('원가관리회계', '제1장')">제1장 원가의 분류와 제조기업의 원가의 흐름</div>
                                <div class="submenu-item" onclick="selectChapter('원가관리회계', '제2장')">제2장 원가배분과 보조부문원가의 배분/개별원가계산</div>
                                <div class="submenu-item" onclick="selectChapter('원가관리회계', '제3장')">제3장 종합원가계산</div>
                                <div class="submenu-item" onclick="selectChapter('원가관리회계', '제4장')">제4장 연산품과 부산물의 원가계산</div>
                                <div class="submenu-item" onclick="selectChapter('원가관리회계', '제5장')">제5장 변동원가계산과 초변동원가계산</div>
                                <div class="submenu-item" onclick="selectChapter('원가관리회계', '제6장')">제6장 활동기준원가계산</div>
                                <div class="submenu-item" onclick="selectChapter('원가관리회계', '제7장')">제7장 원가추정</div>
                                <div class="submenu-item" onclick="selectChapter('원가관리회계', '제8장')">제8장 원가-조업도-이익분석</div>
                                <div class="submenu-item" onclick="selectChapter('원가관리회계', '제9장')">제9장 관련원가분석</div>
                                <div class="submenu-item" onclick="selectChapter('원가관리회계', '제11장')">제11장 불확실성하의 의사결정</div>
                                <div class="submenu-item" onclick="selectChapter('원가관리회계', '제12장')">제12장 종합예산</div>
                                <div class="submenu-item" onclick="selectChapter('원가관리회계', '제13장')">제13장 표준원가계산</div>
                                <div class="submenu-item" onclick="selectChapter('원가관리회계', '제14장')">제14장 판매부문과 투자중심점의 성과평가</div>
                                <div class="submenu-item" onclick="selectChapter('원가관리회계', '제15장')">제15장 대체가격결정</div>
                                <div class="submenu-item" onclick="selectChapter('원가관리회계', '제16장')">제16장 전략적 원가관리</div>
                            </div>
                        </div>
                        <div class="submenu-item" onclick="selectChapter('회계학개론', 'AI추천')">🤖 AI 추천문제</div>
                    </div>
                    <!-- 02-2-1-1. 회계학개론 메뉴 끝 -->
                    
                    <!-- 02-2-1-2. 세법학개론 메뉴 시작 -->
                    <div class="menu-item" onclick="toggleSubmenu('tax')">
                        <div class="menu-item-title">세법학개론</div>
                        <div class="menu-item-desc">법인세법, 소득세법, 부가가치세법 등</div>
                    </div>
                    <div class="submenu" id="tax-submenu">
                        <div class="submenu-item" onclick="toggleSubmenu('tax-yearly')">📅 연도별 기출 ▼</div>
                        <div class="submenu" id="tax-yearly-submenu" style="padding-left: 40px; display: none;">
                            <div class="submenu-item" onclick="selectChapter('세법학개론', '2025년기출')">2025년 제62회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('세법학개론', '2024년기출')">2024년 제61회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('세법학개론', '2023년기출')">2023년 제60회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('세법학개론', '2022년기출')">2022년 제59회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('세법학개론', '2021년기출')">2021년 제58회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('세법학개론', '2020년기출')">2020년 제57회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('세법학개론', '2019년기출')">2019년 제56회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('세법학개론', '2018년기출')">2018년 제55회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('세법학개론', '2017년기출')">2017년 제54회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('세법학개론', '2016년기출')">2016년 제53회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('세법학개론', '2015년기출')">2015년 제52회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('세법학개론', '2014년기출')">2014년 제51회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('세법학개론', '2013년기출')">2013년 제50회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('세법학개론', '2012년기출')">2012년 제49회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('세법학개론', '2011년기출')">2011년 제48회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('세법학개론', '2010년기출')">2010년 제47회 기출</div>
                        </div>
                        
                        <div class="submenu-item" onclick="toggleSubmenu('tax-subject')">📖 세목별 기출 ▼</div>
                        <div class="submenu" id="tax-subject-submenu" style="padding-left: 40px; display: none;">
                            <div class="submenu-item" onclick="toggleSubmenu('corporate-tax')">법인세법 ▼</div>
                            <div class="submenu" id="corporate-tax-submenu" style="padding-left: 40px; display: none;">
                                <div class="submenu-item" onclick="selectChapter('법인세법', '기출문제')">법인세법 기출문제</div>
                                <div class="submenu-item" onclick="toggleSubmenu('corporate-sections')">📖 단원별 기출 ▼</div>
                                <div class="submenu" id="corporate-sections-submenu" style="padding-left: 20px; display: none;">
                                    <div class="submenu-item" onclick="selectChapter('법인세법', '제1절')">제1절 총설</div>
                                    <div class="submenu-item" onclick="selectChapter('법인세법', '제2절')">제2절 법인세의 계산구조</div>
                                    <div class="submenu-item" onclick="selectChapter('법인세법', '제3절')">제3절 익금</div>
                                    <div class="submenu-item" onclick="selectChapter('법인세법', '제4절')">제4절 손금</div>
                                    <div class="submenu-item" onclick="selectChapter('법인세법', '제5절')">제5절 손익의 귀속사업연도와 자산·부채의 평가</div>
                                    <div class="submenu-item" onclick="selectChapter('법인세법', '제6절')">제6절 감가상각</div>
                                    <div class="submenu-item" onclick="selectChapter('법인세법', '제7절')">제7절 충당금과 준비금</div>
                                    <div class="submenu-item" onclick="selectChapter('법인세법', '제8절')">제8절 합병 및 분할 등에 대한 특례</div>
                                    <div class="submenu-item" onclick="selectChapter('법인세법', '제9절')">제9절 부당행위계산의 부인</div>
                                    <div class="submenu-item" onclick="selectChapter('법인세법', '제10절')">제10절 과세표준과 세액의 계산</div>
                                    <div class="submenu-item" onclick="selectChapter('법인세법', '제11절')">제11절 법인세의 납세절차</div>
                                    <div class="submenu-item" onclick="selectChapter('법인세법', '제12절')">제12절 그 밖의 법인세</div>
                                </div>
                            </div>
                            
                            <div class="submenu-item" onclick="toggleSubmenu('income-tax')">소득세법 ▼</div>
                            <div class="submenu" id="income-tax-submenu" style="padding-left: 40px; display: none;">
                                <div class="submenu-item" onclick="selectChapter('소득세법', '기출문제')">소득세법 기출문제</div>
                                <div class="submenu-item" onclick="toggleSubmenu('income-sections')">📖 단원별 기출 ▼</div>
                                <div class="submenu" id="income-sections-submenu" style="padding-left: 20px; display: none;">
                                    <div class="submenu-item" onclick="selectChapter('소득세법', '제1절')">제1절 총설</div>
                                    <div class="submenu-item" onclick="selectChapter('소득세법', '제2절')">제2절 이자소득과 배당소득</div>
                                    <div class="submenu-item" onclick="selectChapter('소득세법', '제3절')">제3절 사업소득</div>
                                    <div class="submenu-item" onclick="selectChapter('소득세법', '제4절')">제4절 근로소득·연금소득 및 기타소득</div>
                                    <div class="submenu-item" onclick="selectChapter('소득세법', '제5절')">제5절 소득금액계산의 특례</div>
                                    <div class="submenu-item" onclick="selectChapter('소득세법', '제6절')">제6절 종합소득과세표준의 계산</div>
                                    <div class="submenu-item" onclick="selectChapter('소득세법', '제7절')">제7절 종합소득세액의 계산</div>
                                    <div class="submenu-item" onclick="selectChapter('소득세법', '제8절')">제8절 퇴직소득세</div>
                                    <div class="submenu-item" onclick="selectChapter('소득세법', '제9절')">제9절 종합·퇴직소득세의 납세절차</div>
                                    <div class="submenu-item" onclick="selectChapter('소득세법', '제10절')">제10절 양도소득세</div>
                                    <div class="submenu-item" onclick="selectChapter('소득세법', '제11절')">제11절 비거주자와 외국법인의 납세의무</div>
                                </div>
                            </div>
                            
                            <div class="submenu-item" onclick="toggleSubmenu('vat')">부가가치세법 ▼</div>
                            <div class="submenu" id="vat-submenu" style="padding-left: 40px; display: none;">
                                <div class="submenu-item" onclick="selectChapter('부가가치세법', '기출문제')">부가가치세법 기출문제</div>
                                <div class="submenu-item" onclick="toggleSubmenu('vat-sections')">📖 단원별 기출 ▼</div>
                                <div class="submenu" id="vat-sections-submenu" style="padding-left: 20px; display: none;">
                                    <div class="submenu-item" onclick="selectChapter('부가가치세법', '제1절')">제1절 총설</div>
                                    <div class="submenu-item" onclick="selectChapter('부가가치세법', '제2절')">제2절 납세의무자</div>
                                    <div class="submenu-item" onclick="selectChapter('부가가치세법', '제3절')">제3절 과세거래</div>
                                    <div class="submenu-item" onclick="selectChapter('부가가치세법', '제4절')">제4절 영세율과 면세</div>
                                    <div class="submenu-item" onclick="selectChapter('부가가치세법', '제5절')">제5절 과세표준</div>
                                    <div class="submenu-item" onclick="selectChapter('부가가치세법', '제6절')">제6절 거래징수와 세금계산서</div>
                                    <div class="submenu-item" onclick="selectChapter('부가가치세법', '제7절')">제7절 납부세액의 계산</div>
                                    <div class="submenu-item" onclick="selectChapter('부가가치세법', '제8절')">제8절 부가가치세의 납세절차</div>
                                    <div class="submenu-item" onclick="selectChapter('부가가치세법', '제9절')">제9절 간이과세</div>
                                </div>
                            </div>
                            
                            <div class="submenu-item" onclick="selectChapter('국세기본법', '기출문제')">국세기본법 기출문제</div>
                            <div class="submenu-item" onclick="selectChapter('국세징수법', '기출문제')">국세징수법 기출문제</div>
                            <div class="submenu-item" onclick="selectChapter('조세범처벌법', '기출문제')">조세범처벌법 기출문제</div>
                        </div>
                        
                        <div class="submenu-item" onclick="selectChapter('세법학개론', 'AI추천')"> 생성문제</div>
                    </div>
                    <!-- 02-2-1-2. 세법학개론 메뉴 끝 -->
                    
                    <!-- 02-2-1-3. 재정학 메뉴 시작 -->
                    <div class="menu-item" onclick="toggleSubmenu('finance')">
                        <div class="menu-item-title"> 재정학</div>
                        <div class="menu-item-desc">공공재, 조세이론, 재정정책</div>
                    </div>
                    <div class="submenu" id="finance-submenu">
                        <div class="submenu-item" onclick="toggleSubmenu('finance-years')">📅 연도별 기출 ▼</div>
                        <div class="submenu" id="finance-years-submenu" style="padding-left: 20px; display: none;">
                            <div class="submenu-item" onclick="selectChapter('재정학', '2025년기출')">2025년 제62회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('재정학', '2024년기출')">2024년 제61회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('재정학', '2023년기출')">2023년 제60회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('재정학', '2022년기출')">2022년 제59회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('재정학', '2021년기출')">2021년 제58회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('재정학', '2020년기출')">2020년 제57회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('재정학', '2019년기출')">2019년 제56회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('재정학', '2018년기출')">2018년 제55회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('재정학', '2017년기출')">2017년 제54회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('재정학', '2016년기출')">2016년 제53회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('재정학', '2015년기출')">2015년 제52회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('재정학', '2014년기출')">2014년 제51회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('재정학', '2013년기출')">2013년 제50회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('재정학', '2012년기출')">2012년 제49회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('재정학', '2011년기출')">2011년 제48회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('재정학', '2010년기출')">2010년 제47회 기출</div>
                        </div>
                        
                        <div class="submenu-item" onclick="toggleSubmenu('finance-chapters')">📖 단원별 기출 ▼</div>
                        <div class="submenu" id="finance-chapters-submenu" style="padding-left: 20px; display: none;">
                            <div class="submenu-item" onclick="toggleSubmenu('finance-part1')">제1편 재정학의 기초 ▼</div>
                            <div class="submenu" id="finance-part1-submenu" style="padding-left: 20px; display: none;">
                                <div class="submenu-item" onclick="selectChapter('재정학', '제1장')">제1장 재정학: 의의와 성격</div>
                                <div class="submenu-item" onclick="selectChapter('재정학', '제2장')">제2장 우리나라의 재정</div>
                                <div class="submenu-item" onclick="selectChapter('재정학', '제3장')">제3장 후생경제학</div>
                            </div>
                            
                            <div class="submenu-item" onclick="toggleSubmenu('finance-part2')">제2편 자원배분의 문제 ▼</div>
                            <div class="submenu" id="finance-part2-submenu" style="padding-left: 20px; display: none;">
                                <div class="submenu-item" onclick="selectChapter('재정학', '제4장')">제4장 공공재의 문제</div>
                                <div class="submenu-item" onclick="selectChapter('재정학', '제5장')">제5장 공공선택의 이론</div>
                                <div class="submenu-item" onclick="selectChapter('재정학', '제6장')">제6장 외부성의 문제</div>
                                <div class="submenu-item" onclick="selectChapter('재정학', '제7장')">제7장 환경정책</div>
                            </div>
                            
                            <div class="submenu-item" onclick="toggleSubmenu('finance-part3')">제3편 분배와 사회복지 ▼</div>
                            <div class="submenu" id="finance-part3-submenu" style="padding-left: 20px; display: none;">
                                <div class="submenu-item" onclick="selectChapter('재정학', '제8장')">제8장 소득분배이론</div>
                                <div class="submenu-item" onclick="selectChapter('재정학', '제9장')">제9장 재분배정책</div>
                                <div class="submenu-item" onclick="selectChapter('재정학', '제10장')">제10장 사회보험제도</div>
                            </div>
                            
                            <div class="submenu-item" onclick="toggleSubmenu('finance-part4')">제4편 공공지출이론 ▼</div>
                            <div class="submenu" id="finance-part4-submenu" style="padding-left: 20px; display: none;">
                                <div class="submenu-item" onclick="selectChapter('재정학', '제11장')">제11장 정부지출의 분석</div>
                                <div class="submenu-item" onclick="selectChapter('재정학', '제12장')">제12장 비용편익분석</div>
                            </div>
                            
                            <div class="submenu-item" onclick="toggleSubmenu('finance-part5')">제5편 조세의 이론 ▼</div>
                            <div class="submenu" id="finance-part5-submenu" style="padding-left: 20px; display: none;">
                                <div class="submenu-item" onclick="selectChapter('재정학', '제13장')">제13장 조세의 기본원리</div>
                                <div class="submenu-item" onclick="selectChapter('재정학', '제14장')">제14장 조세와 소득분배</div>
                                <div class="submenu-item" onclick="selectChapter('재정학', '제15장')">제15장 조세와 효율성</div>
                                <div class="submenu-item" onclick="selectChapter('재정학', '제16장')">제16장 바람직한 조세제도의 탐색</div>
                            </div>
                            
                            <div class="submenu-item" onclick="toggleSubmenu('finance-part6')">제6편 현실의 조세제도 ▼</div>
                            <div class="submenu" id="finance-part6-submenu" style="padding-left: 20px; display: none;">
                                <div class="submenu-item" onclick="selectChapter('재정학', '제17장')">제17장 소득세와 부가가치세</div>
                                <div class="submenu-item" onclick="selectChapter('재정학', '제18장')">제18장 법인세</div>
                                <div class="submenu-item" onclick="selectChapter('재정학', '제19장')">제19장 조세제도의 개혁</div>
                            </div>
                            
                            <div class="submenu-item" onclick="toggleSubmenu('finance-part7')">제7편 조세와 경제행위 ▼</div>
                            <div class="submenu" id="finance-part7-submenu" style="padding-left: 20px; display: none;">
                                <div class="submenu-item" onclick="selectChapter('재정학', '제20장')">제20장 조세와 경제행위: 개인의 선택</div>
                                <div class="submenu-item" onclick="selectChapter('재정학', '제21장')">제21장 조세와 경제행위: 기업의 선택</div>
                            </div>
                            
                            <div class="submenu-item" onclick="toggleSubmenu('finance-part8')">제8편 재정학의 다른 문제들 ▼</div>
                            <div class="submenu" id="finance-part8-submenu" style="padding-left: 20px; display: none;">
                                <div class="submenu-item" onclick="selectChapter('재정학', '제22장')">제22장 재정적자와 국채</div>
                                <div class="submenu-item" onclick="selectChapter('재정학', '제23장')">제23장 공공요금의 이론</div>
                                <div class="submenu-item" onclick="selectChapter('재정학', '제24장')">제24장 지방재정</div>
                            </div>
                        </div>
                        
                        <div class="submenu-item" onclick="selectChapter('재정학', 'AI추천')">🤖 AI 추천문제</div>
                    </div>
                    <!-- 02-2-1-3. 재정학 메뉴 끝 -->
                    
                    <!-- 02-2-1-4. 행정소송법 메뉴 시작 -->
                    <div class="menu-item" onclick="toggleSubmenu('admin')">
                        <div class="menu-item-title"> 행정소송법</div>
                        <div class="menu-item-desc">연도별 & 유형별 문제풀이</div>
                    </div>
                    <div class="submenu" id="admin-submenu">
                        <div class="submenu-item" onclick="toggleSubmenu('admin-years')">📅 연도별 기출 ▼</div>
                        <div class="submenu" id="admin-years-submenu" style="padding-left: 20px; display: none;">
                            <div class="submenu-item" onclick="selectChapter('행정소송법', '2025년기출')">2025년 제62회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('행정소송법', '2024년기출')">2024년 제61회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('행정소송법', '2023년기출')">2023년 제60회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('행정소송법', '2022년기출')">2022년 제59회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('행정소송법', '2021년기출')">2021년 제58회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('행정소송법', '2020년기출')">2020년 제57회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('행정소송법', '2019년기출')">2019년 제56회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('행정소송법', '2018년기출')">2018년 제55회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('행정소송법', '2017년기출')">2017년 제54회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('행정소송법', '2016년기출')">2016년 제53회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('행정소송법', '2015년기출')">2015년 제52회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('행정소송법', '2014년기출')">2014년 제51회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('행정소송법', '2013년기출')">2013년 제50회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('행정소송법', '2012년기출')">2012년 제49회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('행정소송법', '2011년기출')">2011년 제48회 기출</div>
                            <div class="submenu-item" onclick="selectChapter('행정소송법', '2010년기출')">2010년 제47회 기출</div>
                        </div>
                        <div class="submenu-item" onclick="toggleSubmenu('admin-chapters-new')">📖 단원별 기출 (유형별) ▼</div>
                        <div class="submenu" id="admin-chapters-new-submenu" style="padding-left: 20px; display: none;">
                            <div class="submenu-item menu-part-header" onclick="toggleSubmenu('admin-part1')">PART 1: 소송의 제기 (소송요건) ▼</div>
                            <div class="submenu" id="admin-part1-submenu" style="padding-left: 40px; display: none;">
                                <div class="submenu-item" onclick="selectChapter('행정소송법', '제1장: 소송의 대상')">제1장: 소송의 대상 (대상적격)</div>
                                <div class="submenu-item" onclick="selectChapter('행정소송법', '제2장: 소송의 당사자')">제2장: 소송의 당사자</div>
                                <div class="submenu-item" onclick="selectChapter('행정소송법', '제3장: 소의 이익')">제3장: 소의 이익</div>
                                <div class="submenu-item" onclick="selectChapter('행정소송법', '제4장: 제소기간 및 행정심판')">제4장: 제소기간 및 행정심판</div>
                            </div>

                            <div class="submenu-item menu-part-header" onclick="toggleSubmenu('admin-part2')">PART 2: 소송의 진행 (심리/절차) ▼</div>
                            <div class="submenu" id="admin-part2-submenu" style="padding-left: 40px; display: none;">
                                <div class="submenu-item" onclick="selectChapter('행정소송법', '제5장: 가구제')">제5장: 가구제 (집행정지)</div>
                                <div class="submenu-item" onclick="selectChapter('행정소송법', '제6장: 소의 변경, 이송, 병합')">제6장: 소의 변경, 이송 및 병합</div>
                                <div class="submenu-item" onclick="selectChapter('행정소송법', '제7장: 소송의 심리')">제7장: 소송의 심리</div>
                            </div>

                            <div class="submenu-item menu-part-header" onclick="toggleSubmenu('admin-part3')">PART 3: 소송의 종료 (판결) ▼</div>
                            <div class="submenu" id="admin-part3-submenu" style="padding-left: 40px; display: none;">
                                <div class="submenu-item" onclick="selectChapter('행정소송법', '제8장: 판결의 종류')">제8장: 판결의 종류</div>
                                <div class="submenu-item" onclick="selectChapter('행정소송법', '제9장: 판결의 효력')">제9장: 판결의 효력</div>
                            </div>

                            <div class="submenu-item menu-part-header" onclick="toggleSubmenu('admin-part4')">PART 4: 그 밖의 행정소송 ▼</div>
                            <div class="submenu" id="admin-part4-submenu" style="padding-left: 40px; display: none;">
                                <div class="submenu-item" onclick="selectChapter('행정소송법', '제10장: 무효등확인소송')">제10장: 무효등확인소송</div>
                                <div class="submenu-item" onclick="selectChapter('행정소송법', '제11장: 부작위위법확인소송')">제11장: 부작위위법확인소송</div>
                                <div class="submenu-item" onclick="selectChapter('행정소송법', '제12장: 당사자소송')">제12장: 당사자소송</div>
                            </div>
                        </div>

                        <div class="submenu-item" onclick="selectChapter('행정소송법', 'AI추천')">🤖 AI 추천문제</div>
                    </div>
                    <!-- 02-2-1-4. 행정소송법 메뉴 끝 -->
                </div>
                <!-- 02-2-1. 1차 시험 메뉴 섹션 끝 -->
                
                <!-- 02-2-2. 2차 시험 메뉴 섹션 시작 -->
                <div class="menu-section">
                    <div class="menu-section-title"> 2차 시험 문제풀이</div>
                    
                    <div class="menu-item" onclick="selectChapter('회계학1부', '기출문제')">
                        <div class="menu-item-title"> 회계학 1부 (재무회계)</div>
                        <div class="menu-item-desc">연결회계, 고급회계, 특수회계</div>
                    </div>
                    
                    <div class="menu-item" onclick="selectChapter('회계학2부', '기출문제')">
                        <div class="menu-item-title"> 회계학 2부 (세무회계)</div>
                        <div class="menu-item-desc">세무조정, 실무사례</div>
                    </div>
                    
                    <div class="menu-item" onclick="selectChapter('세법학1부', '기출문제')">
                        <div class="menu-item-title"> 세법학 1부 (사례형)</div>
                        <div class="menu-item-desc">국세기본법, 법인세법, 소득세법</div>
                    </div>
                    
                    <div class="menu-item" onclick="selectChapter('세법학2부', '기출문제')">
                        <div class="menu-item-title"> 세법학 2부 (법령형)</div>
                        <div class="menu-item-desc">부가가치세법, 지방세법</div>
                    </div>
                </div>
                <!-- 02-2-2. 2차 시험 메뉴 섹션 끝 -->
            </div>
            <!-- ========================================
                 문제풀이 목차 컨테이너 끝
                 ======================================== -->

                        <!-- ========================================
                 (최종 확정) 이론학습 목차 컨테이너 시작
                 ======================================== -->
            <div id="theory-menu-content" style="display: none;">
                <div class="menu-section">
                    <div class="menu-section-title">📚 통합 이론 학습</div>
                    
                    <!-- 회계학 메뉴 -->
                    <div class="menu-item" onclick="toggleSubmenu('theory-accounting-main')">
                        <div class="menu-item-title">회계학</div>
                    </div>
                    <div class="submenu" id="theory-accounting-main-submenu">
                        <div class="submenu-item" onclick="selectChapter('재무회계', '전체 이론')">재무회계</div>
                        <div class="submenu-item" onclick="selectChapter('원가관리회계', '전체 이론')">원가관리회계</div>
                        <div class="submenu-item" onclick="selectChapter('세무회계', '전체 이론')">세무회계</div>
                    </div>

                    <!-- 세법학 (2차 시험 중심) 메뉴 -->
                    <div class="menu-item" onclick="toggleSubmenu('theory-tax-main')">
                        <div class="menu-item-title">세법학 (2차 중심)</div>
                    </div>
                    <div class="submenu" id="theory-tax-main-submenu">
                        <div class="submenu-item" onclick="selectChapter('국세기본법', '전체 이론')">국세기본법</div>
                        <div class="submenu-item" onclick="selectChapter('소득세법', '전체 이론')">소득세법</div>
                        <div class="submenu-item" onclick="selectChapter('법인세법', '전체 이론')">법인세법</div>
                        <div class="submenu-item" onclick="selectChapter('상속세 및 증여세법', '전체 이론')">상속세 및 증여세법</div>
                        <div class="submenu-item" onclick="selectChapter('부가가치세법', '전체 이론')">부가가치세법</div>
                        <div class="submenu-item" onclick="selectChapter('개별소비세법', '전체 이론')">개별소비세법</div>
                        <div class="submenu-item" onclick="selectChapter('지방세법', '전체 이론')">지방세법</div>
                        <div class="submenu-item" onclick="selectChapter('조세특례제한법', '전체 이론')">조세특례제한법</div>
                    </div>
                    
                    <!-- 기타 세법 (1차 시험 중심) 메뉴 -->
                    <div class="menu-item" onclick="selectChapter('기타세법', '전체 이론')">
                        <div class="menu-item-title">기타세법 (국징, 국조, 조처)</div>
                    </div>

                    <!-- 전략과목 메뉴 -->
                    <div class="menu-item" onclick="toggleSubmenu('theory-strategy-main')">
                        <div class="menu-item-title">전략과목</div>
                    </div>
                    <div class="submenu" id="theory-strategy-main-submenu">
                        <div class="submenu-item" onclick="selectChapter('재정학', '전체 이론')">재정학</div>
                        <div class="submenu-item" onclick="selectChapter('행정소송법', '전체 이론')">행정소송법</div>
                    </div>
                </div>
            </div>
            <!-- ========================================
                 이론학습 목차 컨테이너 끝
                 ======================================== -->

        </div>
        <!-- ========================================
             02-2. 사이드바 네비게이션 메뉴 (목차 구조) 끝
             ======================================== -->


        <!-- ========================================
             02. 오버레이 및 사이드바 섹션 끝
             ======================================== -->
        
                <!-- ========================================
             (통합) 03. 초슬림 한 줄 헤더 섹션 시작
             ======================================== -->
        <header class="unified-header">
            <!-- 03-1. 헤더 왼쪽: 뒤로가기, 현재 위치 -->
            <div class="header-left">
                <button class="header-btn back-btn" onclick="goBack()">←</button>
                <div class="breadcrumb" id="breadcrumb-text">세법 학습 시스템</div>
            </div>

            <!-- 03-2. 헤더 중앙: 메인 탭 (목차 열기 기능 포함) -->
            <div class="header-center">
                <button class="tab-btn active" onclick="switchTab('quiz')">📝 문제풀이</button>
                <button class="tab-btn" onclick="switchTab('progress')">📊 개발중</button>
                <button class="tab-btn" onclick="switchTab('theory')">📚 이론학습</button>          
            </div>

            <!-- 03-3. 헤더 오른쪽: 상세목차, 타이머 -->
            <div class="header-right">
                <button class="header-btn" id="floating-toc-btn" style="display: none;" onclick="toggleFloatingTOC()">📖 상세목차</button>
                <div class="timer-container">
                    <div class="timer-display" id="timer">00:00:00</div>
                    <div class="timer-controls">
                        <button id="start-timer-btn" class="timer-btn start" onclick="startTimer()">▶️</button>
                        <button id="pause-timer-btn" class="timer-btn pause" onclick="pauseTimer()">⏸️</button>
                        <button id="reset-timer-btn" class="timer-btn reset" onclick="resetTimer()">🔄</button>
                    </div>
                </div>
            </div>
        </header>
        <!-- ========================================
             (통합) 03. 초슬림 한 줄 헤더 섹션 끝
             ======================================== -->


        <!-- ========================================
             05. 메인 콘텐츠 섹션 시작
             ======================================== -->
        <main class="main-content">
            <!-- 05-1. 문제풀이 화면 레이아웃 시작 -->
            <div class="quiz-layout" id="quiz-layout">
    <div class="main-column">
        <!-- 05-1-1. 문제풀이(퀴즈) 영역 시작 -->
        <section class="quiz-section" id="quiz-section">
            <!-- 05-1-1-0. 문제 위 스마트 주석(Annotation) 캔버스 -->
            <canvas class="annotation-canvas" id="annotation-canvas"></canvas>
            <!-- 05-1-1-1. 퀴즈 헤더 -->
            <div class="quiz-header">
                <span id="question-counter">문제 준비중</span>
                <span id="quiz-status">대기</span>
            </div>
            <!-- 05-1-1-2. 문제 컨테이너 -->
            <div class="question-container" id="question-container">
                <h3 id="question-text">목차에서 원하는 과목과 단원을 선택해주세요.</h3>
                <div class="options-container" id="options-container"></div>
            </div>
        </section>
        <!-- 05-1-2. 문제풀이/연습장 크기조절바 -->
        <div class="resizer-vertical" id="vertical-resizer"></div>
        <!-- 05-1-3. 하단 연습장(Workspace) -->
        <section class="workspace-section-new" id="workspace-section">
    <div class="workspace-header">
        <h3>✏️ 연습장 (문제별 자동저장)</h3>
        <button class="draw-btn" onclick="clearAllCanvases()">전체 필기 지우기</button>
    </div>
    <canvas class="workspace-canvas" id="workspace-canvas"></canvas>
    </section>
            </div>

            <!-- 05-1-3. 오른쪽: 계산기 영역 시작 -->
                <section class="calculator-section">
                    <!-- 05-1-3-1. 계산기 컨테이너 시작 -->
                    <div class="calculator-container">
                    <div class="calc-brand">CASIO JS-40B</div>
                                          
                    <!-- 05-1-3-1-2. 계산기 디스플레이 (14자리 지원) 시작 -->
                    <div class="calculator-display" id="calc-display">
                    <div class="memory-indicator" id="memory-indicator"></div>
                     <div class="display-value" id="display-value">0</div>
                        </div>
                        <!-- 05-1-3-1-2. 계산기 디스플레이 (14자리 지원) 끝 -->
                        
                        <!-- 05-1-3-1-3. 계산기 버튼 그리드 (5x6) 시작 -->
                        <div class="calculator-buttons">
                            <!-- 05-1-3-1-3-1. 첫 번째 줄: M/EX, %, √, ⌫, GT 시작 -->
                            <button class="calc-btn memory" onclick="memoryExchange()">M/EX</button>
                            <button class="calc-btn function" onclick="percentage()">%</button>
                            <button class="calc-btn function" onclick="squareRoot()">√</button>
                            <button class="calc-btn function" onclick="backspace()">⌫</button>
                            <button class="calc-btn memory" onclick="grandTotal()">GT</button>
                            <!-- 05-1-3-1-3-1. 첫 번째 줄: M/EX, %, √, ⌫, GT 끝 -->
                            
                            <!-- 05-1-3-1-3-2. 두 번째 줄: MC, MR, M-, M+, ÷ 시작 -->
                            <button class="calc-btn memory" onclick="memoryClear()">MC</button>
                            <button class="calc-btn memory" onclick="memoryRecall()">MR</button>
                            <button class="calc-btn memory" onclick="memorySubtract()">M-</button>
                            <button class="calc-btn memory" onclick="memoryAdd()">M+</button>
                            <button class="calc-btn operator" onclick="appendToDisplay('/')">÷</button>
                            <!-- 05-1-3-1-3-2. 두 번째 줄: MC, MR, M-, M+, ÷ 끝 -->
                            
                            <!-- 05-1-3-1-3-3. 세 번째 줄: +/-, 7, 8, 9, × 시작 -->
                            <button class="calc-btn function" onclick="changeSign()">+/-</button>
                            <button class="calc-btn number" onclick="appendToDisplay('7')">7</button>
                            <button class="calc-btn number" onclick="appendToDisplay('8')">8</button>
                            <button class="calc-btn number" onclick="appendToDisplay('9')">9</button>
                            <button class="calc-btn operator" onclick="appendToDisplay('*')">×</button>
                            <!-- 05-1-3-1-3-3. 세 번째 줄: +/-, 7, 8, 9, × 끝 -->
                            
                            <!-- 05-1-3-1-3-4. 네 번째 줄: C, 4, 5, 6, - 시작 -->
                            <button class="calc-btn function" onclick="clearEntry()">C</button>
                            <button class="calc-btn number" onclick="appendToDisplay('4')">4</button>
                            <button class="calc-btn number" onclick="appendToDisplay('5')">5</button>
                            <button class="calc-btn number" onclick="appendToDisplay('6')">6</button>
                            <button class="calc-btn operator" onclick="appendToDisplay('-')">-</button>
                            <!-- 05-1-3-1-3-4. 네 번째 줄: C, 4, 5, 6, - 끝 -->
                            
                            <!-- 05-1-3-1-3-5. 다섯 번째 줄: AC, 1, 2, 3, + (2칸) 시작 -->
                            <button class="calc-btn function" onclick="clearAll()">AC</button>
                            <button class="calc-btn number" onclick="appendToDisplay('1')">1</button>
                            <button class="calc-btn number" onclick="appendToDisplay('2')">2</button>
                            <button class="calc-btn number" onclick="appendToDisplay('3')">3</button>
                            <button class="calc-btn plus-tall" onclick="appendToDisplay('+')">+</button>
                            <!-- 05-1-3-1-3-5. 다섯 번째 줄: AC, 1, 2, 3, + (2칸) 끝 -->
                            
                            <!-- 05-1-3-1-3-6. 여섯 번째 줄: 0, 00, ., = 시작 -->
                            <button class="calc-btn number" onclick="appendToDisplay('0')">0</button>
                            <button class="calc-btn number" onclick="appendToDisplay('00')">00</button>
                            <button class="calc-btn number" onclick="appendToDisplay('.')">.</button>
                            <button class="calc-btn equals" onclick="calculate()">=</button>
                            <!-- 05-1-3-1-3-6. 여섯 번째 줄: 0, 00, ., = 끝 -->
                        </div>
                        <!-- 05-1-3-1-3. 계산기 버튼 그리드 (5x6) 끝 -->

                        <!-- 05-1-3-1-4. 계산기록 영역 시작 -->
                        <div class="calculation-history">
                            <!-- 05-1-3-1-4-1. 계산기록 제목 시작 -->
                            <div class="history-title">
                                계산기록
                                <button class="clear-history-btn" onclick="clearCalculationHistory()">지우기</button>
                            </div>
                            <!-- 05-1-3-1-4-1. 계산기록 제목 끝 -->
                            
                            <!-- 05-1-3-1-4-2. 계산기록 값들 시작 -->
                            <div class="history-values" id="historyValues">
                                <!-- 계산 결과들이 개별 버튼으로 표시됩니다 -->
                            </div>
                            <!-- 05-1-3-1-4-2. 계산기록 값들 끝 -->
                        </div>
                        <!-- 05-1-3-1-4. 계산기록 영역 끝 -->
                    </div>
                    <!-- 05-1-3-1. 계산기 컨테이너 끝 -->
                </section>
                <!-- 05-1-3. 오른쪽: 계산기 영역 끝 -->
            <!-- 05-1. 문제풀이 화면 레이아웃 끝 -->
        <!-- (수정) 05-2. 이론학습 화면 레이아웃 시작 -->
        <div class="theory-layout" id="theory-layout">
            <div class="theory-main-content" id="theoryMainContent">
                <div class="loading-spinner" id="theoryLoadingSpinner" style="display: none;">
                    <!-- 이 내용은 JS에 의해 동적으로 변경됩니다 -->
                </div>
                <div class="theory-book" id="theoryBook">
                    <!-- 이론 콘텐츠가 여기에 동적으로 채워집니다 -->
                </div>
            </div>
        </div>
        <!-- 05-2. 이론학습 화면 레이아웃 끝 -->


                <div id="progress-layout" style="display: none; justify-content: center; align-items: center; font-size: 1.2em; color: #6c757d; height: 100%;">
                📊 학습관리 기능은 준비 중입니다.
            </div>

        </main>
        <!-- ========================================
             05. 메인 콘텐츠 섹션 끝
             ======================================== -->
    </div>

    <!-- (신규) 오른쪽 플로팅 상세목차(TOC) 시작 -->
    <div class="floating-toc" id="floating-toc">
        <div class="floating-toc-header">
            <h3>상세 목차</h3>
            <button class="close-btn" onclick="toggleFloatingTOC()">&times;</button>
        </div>
        <ul class="floating-toc-list" id="floating-toc-list">
            <!-- JS가 여기에 동적으로 목차를 채웁니다. -->
            <li>목차 정보가 없습니다.</li>
        </ul>
    </div>
    <!-- (신규) 오른쪽 플로팅 상세목차(TOC) 끝 -->

    <!-- ========================================
         06. JavaScript 기능 구현 섹션 시작
         ======================================== -->
    <script>
/* ===== 06-1. 전역 변수 선언 (수정) 시작 ===== */
let calculatorMemory = 0;
let grandTotalMemory = 0;
let shouldClearOnNextInput = false;
let currentExpression = '';
let calculationHistory = [];
let viewHistory = [];

// 캔버스 관련 전역 변수
let annotationCanvas, annotationCtx;
let workspaceCanvas, workspaceCtx;
let workspaceStates = {};
let annotationStates = {};

// 스마트 캔버스 상호작용을 위한 변수
let isPointerDown = false;      // 포인터(마우스/터치)가 눌렸는지 여부
let isDragging = false;         // '필기(드래그)' 동작으로 확정되었는지 여부
let pointerDownTime = 0;        // 포인터가 눌린 시각
let startCoords = { x: 0, y: 0 }; // 포인터가 눌린 화면 좌표
let lastCanvasCoords = { x: 0, y: 0 }; // 캔버스 내 마지막 좌표
let isEraserMode = false; // (추가) 지우개 모드 상태 변수

// 스마트 캔버스 판정 기준 (임계값)
const TAP_THRESHOLD_MS = 200;   // '탭'으로 간주할 최대 시간 (0.2초)
const DRAG_THRESHOLD_PX = 5;    // '필기'로 간주할 최소 이동 거리 (5픽셀)

// 퀴즈 상태 관련 전역 변수
let currentView = 'home';
let currentQuestionData = null;
let currentQuestionSet = [];
let currentQuestionIndex = 0;
let userAnswers = {};
let selectedAnswers = {};
let quizCompleted = false;
let activeTab = 'quiz'; // (추가) 현재 활성화된 탭('quiz' 또는 'theory')을 추적합니다.
/* ===== 06-1. 전역 변수 선언 (수정) 끝 ===== */

        /* ===== 06-2. 숫자 포맷팅 함수들 시작 ===== */
        // 06-2-1. 천단위 콤마 추가 함수 시작
        function formatNumberWithCommas(num) {
            return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        }
        // 06-2-1. 천단위 콤마 추가 함수 끝

        // 06-2-2. 콤마 제거 함수 시작
        function removeCommas(str) {
            return str.replace(/,/g, '');
        }
        // 06-2-2. 콤마 제거 함수 끝

        // 06-2-3. 14자리 제한 함수 (F모드 구현) 시작
        function limitTo14Digits(value) {
            const cleanValue = removeCommas(value.toString());
            if (cleanValue.length > 14) {
                return cleanValue.substring(0, 14);
            }
            return cleanValue;
        }
        // 06-2-3. 14자리 제한 함수 (F모드 구현) 끝
        /* ===== 06-2. 숫자 포맷팅 함수들 끝 ===== */

        /* ===== 06-3. 메모리 관련 함수들 시작 ===== */
        // 06-3-1. 메모리 표시 업데이트 (왼쪽 위 M 표시) 시작
        function updateMemoryIndicator() {
            const memoryIndicator = document.getElementById('memory-indicator');
            if (calculatorMemory !== 0) {
                memoryIndicator.textContent = 'M';
            } else {
                memoryIndicator.textContent = '';
            }
        }
        // 06-3-1. 메모리 표시 업데이트 (왼쪽 위 M 표시) 끝
        /* ===== 06-3. 메모리 관련 함수들 끝 ===== */

        /* ===== 06-4. 디스플레이 관련 함수들 시작 ===== */
        // 06-4-1. 디스플레이 업데이트 (콤마 포함, 14자리 제한) 시작
        function updateDisplay(value) {
            const displayElement = document.getElementById('display-value');
            const limitedValue = limitTo14Digits(value);
            
            if (!isNaN(limitedValue) && limitedValue !== '' && !limitedValue.includes('Error')) {
                const numValue = parseFloat(limitedValue);
                if (Number.isInteger(numValue) && numValue >= 1000) {
                    displayElement.textContent = formatNumberWithCommas(numValue);
                } else {
                    displayElement.textContent = limitedValue;
                }
            } else {
                displayElement.textContent = limitedValue;
            }
        }
        // 06-4-1. 디스플레이 업데이트 (콤마 포함, 14자리 제한) 끝

        // 06-4-2. 백스페이스 기능 시작
        function backspace() {
            const currentDisplay = document.getElementById('display-value').textContent;
            const cleanDisplay = removeCommas(currentDisplay);
            
            if (cleanDisplay.length > 1) {
                const newValue = cleanDisplay.slice(0, -1);
                updateDisplay(newValue);
                currentExpression = newValue;
            } else {
                updateDisplay('0');
                currentExpression = '0';
            }
            shouldClearOnNextInput = false;
        }
        // 06-4-2. 백스페이스 기능 끝
        /* ===== 06-4. 디스플레이 관련 함수들 끝 ===== */

        /* ===== 06-5. 계산기록 관리 함수들 시작 ===== */
// 06-5-1. 계산 기록에 값 추가 시작
function addToCalculationHistory(value) {
    if (!isNaN(value) && value !== 0) {
        calculationHistory.push(value);
        if (calculationHistory.length > 20) {
            calculationHistory.shift(); // 최대 20개까지만 유지
        }
        updateHistoryDisplay();
    }
}
// 06-5-1. 계산 기록에 값 추가 끝

// 06-5-2. 계산 기록 표시 업데이트 (중복 제거된 최종 버전)
function updateHistoryDisplay() {
    const historyElement = document.getElementById('historyValues');
    if (!historyElement) return; // historyElement가 없는 화면(결과창 등)에서 오류 방지

    historyElement.innerHTML = '';
    
    if (calculationHistory.length === 0) {
        historyElement.innerHTML = '<span style="color: #6c757d; font-size: 11px;">계산 결과가 여기에 표시됩니다</span>';
    } else {
        calculationHistory.forEach((value, index) => {
            const valueButton = document.createElement('span');
            valueButton.className = 'history-value';
            valueButton.textContent = formatNumberWithCommas(value);
            valueButton.onclick = () => useHistoryValue(value);
            historyElement.appendChild(valueButton);
        });
    }
}
// 06-5-2. 계산 기록 표시 업데이트 끝

// 06-5-3. 계산기록 값 사용
function useHistoryValue(value) {
    const currentDisplay = document.getElementById('display-value').textContent;
    
    if (['+', '-', '×', '÷', '*', '/'].includes(currentDisplay.trim())) {
        updateDisplay(value.toString());
    } else {
        if (shouldClearOnNextInput) {
            updateDisplay(value.toString());
        } else {
            const cleanDisplay = removeCommas(currentDisplay);
            if (cleanDisplay === '0') {
                updateDisplay(value.toString());
            } else {
                const newValue = cleanDisplay + value.toString();
                updateDisplay(limitTo14Digits(newValue));
            }
        }
    }
    shouldClearOnNextInput = false;
    currentExpression = removeCommas(document.getElementById('display-value').textContent);
}
// 06-5-3. 계산기록 값 사용 끝

// 06-5-4. 계산 기록 전체 삭제 시작
function clearCalculationHistory() {
    calculationHistory = [];
    updateHistoryDisplay();
}
// 06-5-4. 계산 기록 전체 삭제 끝
/* ===== 06-5. 계산기록 관리 함수들 끝 ===== */

        
        /* ===== 06-7. 기본 계산기 함수들 시작 ===== */
        // 06-7-1. 숫자/연산자 입력 처리 시작
        function appendToDisplay(value) {
            if (shouldClearOnNextInput) {
                updateDisplay(value);
                shouldClearOnNextInput = false;
            } else {
                const currentDisplay = document.getElementById('display-value').textContent;
                const cleanDisplay = removeCommas(currentDisplay);
                
                if (cleanDisplay === '0' && value !== '.') {
                    updateDisplay(value);
                } else {
                    const newValue = cleanDisplay + value;
                    updateDisplay(limitTo14Digits(newValue));
                }
            }
            currentExpression = removeCommas(document.getElementById('display-value').textContent);
        }
        // 06-7-1. 숫자/연산자 입력 처리 끝

        // 06-7-2. 전체 지우기 (AC) 시작
        function clearAll() {
            updateDisplay('0');
            currentExpression = '';
            shouldClearOnNextInput = false;
        }
        // 06-7-2. 전체 지우기 (AC) 끝

        // 06-7-3. 현재 입력 지우기 (C) 시작
        function clearEntry() {
            updateDisplay('0');
            shouldClearOnNextInput = false;
        }
        // 06-7-3. 현재 입력 지우기 (C) 끝

        // 06-7-4. 계산 실행 (=) 시작
        function calculate() {
            try {
                const cleanExpression = removeCommas(document.getElementById('display-value').textContent);
                const expression = cleanExpression.replace(/×/g, '*').replace(/÷/g, '/');
                const result = eval(expression);
                grandTotalMemory += result;
                
                addToCalculationHistory(result);
                
                updateDisplay(result.toString());
                currentExpression = result.toString();
                shouldClearOnNextInput = true;
            } catch (error) {
                updateDisplay('Error');
            }
        }
        // 06-7-4. 계산 실행 (=) 끝
        /* ===== 06-7. 기본 계산기 함수들 끝 ===== */

        /* ===== 06-8. 메모리 기능 함수들 시작 ===== */
        // 06-8-1. 메모리에 더하기 (M+) 시작
        function memoryAdd() {
            const currentDisplay = document.getElementById('display-value').textContent;
            const cleanDisplay = removeCommas(currentDisplay);
            
            if (/[\+\-\*\/×÷]/.test(cleanDisplay)) {
                try {
                    const expression = cleanDisplay.replace(/×/g, '*').replace(/÷/g, '/');
                    const result = eval(expression);
                    updateDisplay(result.toString());
                    calculatorMemory += result;
                    addToCalculationHistory(result);
                } catch (error) {
                    const currentValue = parseFloat(cleanDisplay) || 0;
                    calculatorMemory += currentValue;
                    addToCalculationHistory(currentValue);
                }
            } else {
                const currentValue = parseFloat(cleanDisplay) || 0;
                calculatorMemory += currentValue;
                addToCalculationHistory(currentValue);
            }
            updateMemoryIndicator();
            shouldClearOnNextInput = true;
        }
        // 06-8-1. 메모리에 더하기 (M+) 끝

        // 06-8-2. 메모리에서 빼기 (M-) 시작
        function memorySubtract() {
            const currentDisplay = document.getElementById('display-value').textContent;
            const cleanDisplay = removeCommas(currentDisplay);
            
            if (/[\+\-\*\/×÷]/.test(cleanDisplay)) {
                try {
                    const expression = cleanDisplay.replace(/×/g, '*').replace(/÷/g, '/');
                    const result = eval(expression);
                    updateDisplay(result.toString());
                    calculatorMemory -= result;
                } catch (error) {
                    const currentValue = parseFloat(cleanDisplay) || 0;
                    calculatorMemory -= currentValue;
                }
            } else {
                const currentValue = parseFloat(cleanDisplay) || 0;
                calculatorMemory -= currentValue;
            }
            updateMemoryIndicator();
            shouldClearOnNextInput = true;
        }
        // 06-8-2. 메모리에서 빼기 (M-) 끝

        // 06-8-3. 메모리 불러오기 (MR) 시작
        function memoryRecall() {
            updateDisplay(calculatorMemory.toString());
            shouldClearOnNextInput = true;
        }
        // 06-8-3. 메모리 불러오기 (MR) 끝

        // 06-8-4. 메모리 지우기 (MC) 시작
        function memoryClear() {
            calculatorMemory = 0;
            updateMemoryIndicator();
        }
        // 06-8-4. 메모리 지우기 (MC) 끝

        // 06-8-5. 메모리 교환 (M/EX) 시작
        function memoryExchange() {
            const currentDisplay = document.getElementById('display-value').textContent;
            const currentValue = parseFloat(removeCommas(currentDisplay)) || 0;
            const temp = calculatorMemory;
            calculatorMemory = currentValue;
            updateDisplay(temp.toString());
            updateMemoryIndicator();
            shouldClearOnNextInput = true;
        }
        // 06-8-5. 메모리 교환 (M/EX) 끝

        // 06-8-6. 총합 표시 (GT) 시작
        function grandTotal() {
            updateDisplay(grandTotalMemory.toString());
            shouldClearOnNextInput = true;
        }
        // 06-8-6. 총합 표시 (GT) 끝
        /* ===== 06-8. 메모리 기능 함수들 끝 ===== */

        /* ===== 06-9. 특수 기능 함수들 시작 ===== */
        // 06-9-1. 퍼센트 계산 (%) 시작
        function percentage() {
            const currentDisplay = document.getElementById('display-value').textContent;
            const value = parseFloat(removeCommas(currentDisplay));
            const result = value / 100;
            updateDisplay(result.toString());
            addToCalculationHistory(result);
            shouldClearOnNextInput = true;
        }
        // 06-9-1. 퍼센트 계산 (%) 끝

        // 06-9-2. 제곱근 계산 (√) 시작
        function squareRoot() {
            const currentDisplay = document.getElementById('display-value').textContent;
            const value = parseFloat(removeCommas(currentDisplay));
            const result = Math.sqrt(value);
            updateDisplay(result.toString());
            addToCalculationHistory(result);
            shouldClearOnNextInput = true;
        }
        // 06-9-2. 제곱근 계산 (√) 끝

        // 06-9-3. 부호 변경 (+/-) 시작
        function changeSign() {
            const currentDisplay = document.getElementById('display-value').textContent;
            const value = parseFloat(removeCommas(currentDisplay));
            updateDisplay((-value).toString());
        }
        // 06-9-3. 부호 변경 (+/-) 끝
        /* ===== 06-9. 특수 기능 함수들 끝 ===== */

        /* ===== 06-10. 사이드바 관련 함수들 (다중 중첩 메뉴 지원) 시작 ===== */
        // 06-10-1. 사이드바 토글 시작
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('overlay');
            
            if (sidebar.classList.contains('open')) {
                sidebar.classList.remove('open');
                overlay.classList.remove('show');
            } else {
                sidebar.classList.add('open');
                overlay.classList.add('show');
            }
        }
        // 06-10-1. 사이드바 토글 끝

        // 06-10-2. 사이드바 닫기 시작
        function closeSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('overlay');
            sidebar.classList.remove('open');
            overlay.classList.remove('show');
        }
        // 06-10-2. 사이드바 닫기 끝

        // 06-10-3. 서브메뉴 토글 (다중 중첩 지원) 시작
        function toggleSubmenu(menuId) {
            const submenu = document.getElementById(menuId + '-submenu');
            if (submenu) {
                if (submenu.classList.contains('show') || submenu.style.display === 'block') {
                    submenu.classList.remove('show');
                    submenu.style.display = 'none';
                } else {
                    submenu.classList.add('show');
                    submenu.style.display = 'block';
                }
            }
        }
        // 06-10-3. 서브메뉴 토글 (다중 중첩 지원) 끝

/* ===== (수정) 06-10-4. 과목/단원 선택 처리 함수 (사이드바 닫기 추가) ===== */
async function selectChapter(subject, chapter, isReturning = false) {
    // 챕터 선택 시, 즉시 사이드바를 닫아 사용자 경험을 개선합니다.
    closeSidebar(); 

    console.log(`🎯 selectChapter 호출됨: ${subject}, ${chapter} (활성탭: ${activeTab})`);

    if (activeTab === 'quiz') {
        await loadQuizChapter(subject, chapter, isReturning);
    } else if (activeTab === 'theory') {
        await loadTheoryChapter(subject, chapter);
    } else {
        console.log(`${activeTab} 탭에서는 챕터 선택 기능이 정의되지 않았습니다.`);
    }
}


// (수정) 06-10-4-1. 퀴즈 챕터 로딩 함수
async function loadQuizChapter(subject, chapter, isReturning) {
    if (!document.getElementById('quiz-layout')) {
        const mainContent = document.querySelector('.main-content');
        if (mainContent) { mainContent.innerHTML = getMainContentHTML(); }
    }
    
    const breadcrumb = document.getElementById('breadcrumb-text');
    const questionText = document.getElementById('question-text');
    const optionsContainer = document.getElementById('options-container');

    if (!breadcrumb || !questionText || !optionsContainer) {
        console.error('❌ 필수 DOM 요소를 찾을 수 없습니다.');
        return;
    }

    // 경로 표시 로직 (생략하지 않음)
    let path = ['1차 시험 문제풀이'];
    const subjectToPath = {
        '재무회계': ['회계학개론', '과목별 기출'], '원가관리회계': ['회계학개론', '과목별 기출'], '회계학개론': ['회계학개론'],
        '법인세법': ['세법학개론', '세목별 기출'], '소득세법': ['세법학개론', '세목별 기출'], '부가가치세법': ['세법학개론', '세목별 기출'],
        '국세기본법': ['세법학개론', '세목별 기출'], '국세징수법': ['세법학개론', '세목별 기출'], '조세범처벌법': ['세법학개론', '세목별 기출'],
        '세법학개론': ['세법학개론'], '재정학': ['재정학'], '행정소송법': ['행정소송법'],
    };
    if (subjectToPath[subject]) { path.push(...subjectToPath[subject]); }
    path.push(chapter.includes('기출문제') || chapter.includes('AI추천') ? chapter : `단원별 기출 > ${chapter}`);
    breadcrumb.innerHTML = path.map((p, i) => i === path.length - 1 ? `<span class="current">${p.split(' > ').pop()}</span>` : `<span>${p}</span>`).join(' &gt; ');

    questionText.textContent = `${subject} ${chapter} 문제를 불러오는 중...`;
    optionsContainer.innerHTML = '';
    
    if (!isReturning) { resetQuizState(); }
    
    // closeSidebar(); // 이 함수는 상위 함수인 selectChapter에서 이미 호출되므로 중복 제거
    // switchTab('quiz'); // (핵심 수정) 이 라인을 제거하여 사이드바가 다시 열리는 것을 방지합니다.

    try {
        const questions = await loadQuestionsFromBack4App(subject, chapter, subject);
        
        if (questions.length > 0) {
            currentQuestionSet = questions;
            currentQuestionIndex = 0;
            if (!isReturning) { pushToViewHistory({ view: 'quiz', data: { subject, chapter } }); }
            setupQuizInterface();
            loadQuestion(questions[0]);
            updateQuestionCounter();
        } else {
            questionText.textContent = `${subject} ${chapter}에 해당하는 문제가 없습니다. 데이터베이스를 확인해주세요.`;
        }
    } catch (error) {
        console.error('❌ 문제 로딩 실패:', error);
        questionText.textContent = '문제를 불러오는 중 오류가 발생했습니다.';
    }
}


/* ===== (최종 수정) 06-10-4-2. 이론 챕터 로딩 함수 (플로팅 목차 연동) ===== */
async function loadTheoryChapter(subject, chapter) {
    const breadcrumb = document.getElementById('breadcrumb-text');
    const loadingSpinner = document.getElementById('theoryLoadingSpinner');
    const theoryBook = document.getElementById('theoryBook');
    const theoryMainContent = document.getElementById('theoryMainContent');

    if (!breadcrumb || !loadingSpinner || !theoryBook || !theoryMainContent) return;

    loadingSpinner.innerHTML = `📚 <strong>${subject} &gt; ${chapter}</strong> 이론을 불러오는 중...`;
    loadingSpinner.style.display = 'block';
    theoryBook.style.display = 'none';
    theoryBook.innerHTML = '';
    
    // 경로 업데이트 (생략하지 않음)
    let path = ['이론학습', subject, chapter];
    breadcrumb.innerHTML = path.map((p, i) => i === path.length - 1 ? `<span class="current">${p}</span>` : `<span>${p}</span>`).join(' &gt; ');

    try {
        const theoryContents = await loadTheoryContentFromBack4App(subject, chapter);
        
        if (theoryContents.length > 0) {
            renderTheoryBook(theoryContents);      // 1. 책 내용 그리기
            // setupTheoryBookNavigation();      // 2. 책 넘김(스와이프) 기능 설정
            
            // 3. (핵심 추가) 플로팅 목차 생성 및 스크롤 스파이 이벤트 연결
            const theoryPage = document.querySelector('.theory-page');
            if (theoryPage) {
                renderFloatingTOC(theoryBook); // 본문 내용 기반으로 목차 생성
                
                // 기존 스크롤 이벤트 리스너 제거 후 새로 추가 (중복 방지)
                theoryPage.removeEventListener('scroll', updateScrollSpy);
                theoryPage.addEventListener('scroll', updateScrollSpy);
            }
            
            loadingSpinner.style.display = 'none';
            theoryBook.style.display = 'flex';
        } else {
            loadingSpinner.innerHTML = `😥 해당 챕터(<strong>${subject} &gt; ${chapter}</strong>)에 대한 이론 콘텐츠가 아직 준비되지 않았습니다.`;
        }
    } catch (error) {
        console.error('❌ 이론 콘텐츠 로딩 실패:', error);
        loadingSpinner.innerHTML = '이론 콘텐츠를 불러오는 중 오류가 발생했습니다.';
    }
}


// (신규) 06-10-5. 이론 콘텐츠를 '두 페이지 보기'로 렌더링하는 함수
function renderTheoryBook(contents) {
    const theoryBook = document.getElementById('theoryBook');
    if (!theoryBook) return;

    // 1. 데이터를 'pageGroup' 기준으로 그룹화하여 펼친 페이지 단위로 묶습니다.
    const pagesByGroup = contents.reduce((acc, item) => {
        const group = item.pageGroup;
        if (!acc[group]) acc[group] = [];
        acc[group].push(item.content);
        return acc;
    }, {});

    let finalHtml = '';
    let pageCounter = 1;
    // 2. 그룹화된 데이터를 기반으로 '펼친 페이지(page-spread)' HTML을 생성합니다.
    Object.values(pagesByGroup).sort((a,b) => a[0].pageGroup - b[0].pageGroup).forEach(groupContents => {
        const leftPageContent = groupContents[0] || '';
        const rightPageContent = groupContents.length > 1 ? groupContents[1] : '';

        finalHtml += `
            <div class="theory-page-spread">
                <div class="theory-page theory-left-page">
                    <div class="theory-content-wrapper">${leftPageContent}</div>
                    <div class="theory-page-number">${pageCounter++}</div>
                </div>
                <div class="theory-page theory-right-page">
                    <div class="theory-content-wrapper">${rightPageContent}</div>
                    <div class="theory-page-number">${pageCounter++}</div>
                </div>
            </div>
        `;
    });
    
    // theoryBook의 너비를 페이지 수에 맞게 동적으로 설정합니다.
    theoryBook.style.width = `${Object.keys(pagesByGroup).length * 100}%`;
    theoryBook.innerHTML = finalHtml;
}

// (개선) 06-10-6. 이론 책 넘김(스와이프) 기능 설정 함수
function setupTheoryBookNavigation() {
    const book = document.getElementById('theoryBook');
    const mainContent = document.getElementById('theoryMainContent');
    if (!book || !mainContent) return;

    const spreads = book.querySelectorAll('.theory-page-spread');
    if (spreads.length === 0) return;

    let currentPage = 0;
    let isDragging = false;
    let startPos = 0;
    let currentTranslate = 0;
    let prevTranslate = 0;
    
    // (수정) spreadWidth를 let으로 선언하여 나중에 변경할 수 있도록 합니다.
    let spreadWidth = mainContent.clientWidth;

    function setPositionByIndex() {
        currentTranslate = currentPage * -spreadWidth;
        prevTranslate = currentTranslate;
        book.style.transform = `translateX(${currentTranslate}px)`;
    }

    setPositionByIndex();

    book.addEventListener('mousedown', dragStart);
    book.addEventListener('touchstart', dragStart, { passive: true });
    book.addEventListener('mouseup', dragEnd);
    book.addEventListener('touchend', dragEnd);
    book.addEventListener('mouseleave', dragEnd);
    book.addEventListener('mousemove', drag);
    book.addEventListener('touchmove', drag, { passive: true });

    // (핵심 수정) 창 크기 변경 시, spreadWidth를 다시 계산하고 위치를 재설정합니다.
    window.addEventListener('resize', () => {
        spreadWidth = mainContent.clientWidth; // 페이지 너비를 다시 계산
        setPositionByIndex();
    });

    function getPositionX(event) {
        return event.type.includes('mouse') ? event.pageX : event.touches[0].clientX;
    }

    function dragStart(event) {
        isDragging = true;
        startPos = getPositionX(event);
        book.style.transition = 'none';
    }

    function drag(event) {
        if (isDragging) {
            const currentPosition = getPositionX(event);
            currentTranslate = prevTranslate + currentPosition - startPos;
            book.style.transform = `translateX(${currentTranslate}px)`;
        }
    }

    function dragEnd(event) {
        if (!isDragging) return;
        isDragging = false;
        const movedBy = currentTranslate - prevTranslate;
        if (movedBy < -spreadWidth / 5 && currentPage < spreads.length - 1) {
            currentPage++;
        }
        if (movedBy > spreadWidth / 5 && currentPage > 0) {
            currentPage--;
        }
        book.style.transition = 'transform 0.3s ease-out';
        setPositionByIndex();
    }
}


/* ===== (신규) 06-11. 플로팅 목차(TOC) 관련 함수들 시작 ===== */

// 06-11-1. 오른쪽 플로팅 목차를 열고 닫는 함수
function toggleFloatingTOC() {
    const toc = document.getElementById('floating-toc');
    toc.classList.toggle('open');
}

// 06-11-2. 이론 본문 내용을 기반으로 플로팅 목차를 동적으로 생성하는 함수
function renderFloatingTOC(contentContainer) {
    const tocList = document.getElementById('floating-toc-list');
    tocList.innerHTML = '';
    const headings = contentContainer.querySelectorAll('h1, h2, h3');

    if (headings.length === 0) {
        tocList.innerHTML = '<li>상세 목차가 없습니다.</li>';
        return;
    }

    headings.forEach((heading, index) => {
        const id = `toc-heading-${index}`;
        heading.id = id; // 본문 제목에 ID 부여

        const li = document.createElement('li');
        const a = document.createElement('a');
        a.href = `#${id}`;
        a.textContent = heading.textContent;
        a.dataset.level = heading.tagName.toLowerCase(); // h1, h2, h3 구분을 위해 데이터 속성 추가
        a.dataset.targetId = id; // 스크롤 스파이에서 사용할 타겟 ID

        a.onclick = (e) => {
            e.preventDefault();
            heading.scrollIntoView({ behavior: 'smooth', block: 'start' });
            toggleFloatingTOC(); // 목차 항목 클릭 시 자동으로 닫기
        };

        li.appendChild(a);
        tocList.appendChild(li);
    });
}

// 06-11-3. 본문 스크롤에 따라 플로팅 목차를 하이라이트하는 '스크롤 스파이' 함수
function updateScrollSpy() {
    const headings = document.querySelectorAll('.theory-content-wrapper h1, .theory-content-wrapper h2, .theory-content-wrapper h3');
    const tocLinks = document.querySelectorAll('.floating-toc-list a');
    let activeId = null;

    // 화면 상단에서 150px 아래 지점을 기준으로 활성 섹션을 찾습니다.
    const scrollThreshold = 150; 

    for (let i = headings.length - 1; i >= 0; i--) {
        const heading = headings[i];
        const rect = heading.getBoundingClientRect();
        if (rect.top <= scrollThreshold) {
            activeId = heading.id;
            break;
        }
    }

    tocLinks.forEach(link => {
        link.classList.remove('active');
        if (link.dataset.targetId === activeId) {
            link.classList.add('active');
        }
    });
}
/* ===== (신규) 06-11. 플로팅 목차(TOC) 관련 함수들 끝 ===== */

/* ===== 06-12. 기타 UI 함수들 시작 ===== */

// 06-12-0. 화면 이동 기록을 관리하는 함수
function pushToViewHistory(state) {
    if (viewHistory.length > 0) {
        const lastView = viewHistory[viewHistory.length - 1];
        if (lastView.view === state.view && JSON.stringify(lastView.data) === JSON.stringify(state.data)) {
            return;
        }
    }
    viewHistory.push(state);
    updateBackButtonState();
}

// 06-12-1. 뒤로가기 버튼 상태 업데이트 함수
function updateBackButtonState() {
    const backBtn = document.querySelector('.back-btn');
    if(backBtn) {
        backBtn.disabled = (viewHistory.length <= 1);
    }
}

// 06-12-2. 퀴즈 상태 초기화 함수
function resetQuizState() {
    console.log('🔄 퀴즈 상태 초기화');
    currentQuestionSet = [];
    currentQuestionIndex = 0;
    selectedAnswers = {};
    userAnswers = {};
    quizCompleted = false;
    workspaceStates = {}; // 연습장 상태 초기화
    annotationStates = {}; // (추가) 주석 상태 초기화
    if(typeof resetTimer === 'function') {
        resetTimer();
    }
}

// (수정) 06-12-3. 초기 화면으로 돌아가는 함수
function goHome() {
    console.log('🏠 초기 화면으로 돌아가기');
    viewHistory = []; 
    pushToViewHistory({ view: 'home', data: null });
    
    const mainContent = document.querySelector('.main-content');
    mainContent.innerHTML = getMainContentHTML(); 

    document.getElementById('breadcrumb-text').innerHTML = '세법 학습 시스템';
    
    // 화면을 그린 직후, 관련 기능들을 초기화합니다.
    setupQuizInterface();
    updateHistoryDisplay();

    // (핵심 수정) switchTab 대신, 초기 화면 상태를 직접 설정합니다.
    // 이렇게 하면 사이드바가 열리지 않습니다.
    activeTab = 'quiz';
    document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
    document.querySelector('.tab-btn[onclick="switchTab(\'quiz\')"]').classList.add('active');
    document.getElementById('quiz-layout').style.display = 'flex';
    document.getElementById('theory-layout').style.display = 'none';
    document.getElementById('progress-layout').style.display = 'none';
}


// 06-12-4. 뒤로가기 기능 구현 (새로운 로직)
function goBack() {
    if (viewHistory.length <= 1) {
        goHome();
        return;
    }

    viewHistory.pop(); // 현재 뷰를 히스토리에서 제거
    const previousState = viewHistory[viewHistory.length - 1];
    console.log("뒤로가기 실행. 되돌아갈 화면:", previousState);

    // 이전 상태에 따라 화면을 복원 (함수를 다시 호출하여 화면을 그림)
    switch (previousState.view) {
        case 'quiz':
            selectChapter(previousState.data.subject, previousState.data.chapter, true); // isReturning = true
            break;
        case 'results':
            showResults();
            break;
        case 'detail':
            showQuestionDetail(previousState.data);
            break;
        case 'allExplanations':
            showAllExplanations();
            break;
        default:
            goHome();
            break;
    }
}

/* ===== (최종 수정) 06-12-5. 탭 전환 함수 (화면 복구 기능 추가) ===== */
function switchTab(tabName) {
    // (핵심 로직) 현재 화면에 퀴즈/이론 레이아웃이 없는지 확인합니다.
    // 없다면(예: 결과화면), 메인 화면 뼈대부터 다시 그립니다.
    if (!document.getElementById('quiz-layout')) {
        console.log('뼈대 없음! 메인 레이아웃을 다시 그립니다.');
        const mainContent = document.querySelector('.main-content');
        mainContent.innerHTML = getMainContentHTML();
        // 뼈대를 다시 그렸으므로, 필요한 기능들을 다시 연결해줍니다.
        setupQuizInterface();
        updateHistoryDisplay();
    }

    activeTab = tabName;
    console.log(`📘 탭 전환: ${tabName}, 사이드바를 엽니다.`);

    // 1. 모든 탭 버튼의 활성 상태를 초기화하고, 클릭된 탭만 활성화합니다.
    document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
    const activeButton = document.querySelector(`.tab-btn[onclick="switchTab('${tabName}')"]`);
    if (activeButton) activeButton.classList.add('active');

    // 2. 모든 메인 레이아웃을 숨깁니다.
    document.getElementById('quiz-layout').style.display = 'none';
    document.getElementById('theory-layout').style.display = 'none';
    document.getElementById('progress-layout').style.display = 'none';
    
    // 3. 오른쪽 상세 목차 버튼('📖 상세목차')의 표시 여부를 결정합니다.
    const floatingTocBtn = document.getElementById('floating-toc-btn');
    if (floatingTocBtn) {
        floatingTocBtn.style.display = (tabName === 'theory') ? 'inline-flex' : 'none';
    }

    const sidebar = document.getElementById('sidebar');
    const overlay = document.getElementById('overlay');
    const sidebarTitle = document.getElementById('sidebar-title');
    const quizMenu = document.getElementById('quiz-menu-content');
    const theoryMenu = document.getElementById('theory-menu-content');

    // 4. 탭 종류에 따라 다른 동작을 수행합니다.
    if (tabName === 'quiz') {
        document.getElementById('quiz-layout').style.display = 'flex';
        sidebarTitle.textContent = '📝 문제풀이 목차';
        quizMenu.style.display = 'block';
        theoryMenu.style.display = 'none';
        sidebar.classList.add('open');
        overlay.classList.add('show');
    } else if (tabName === 'theory') {
        document.getElementById('theory-layout').style.display = 'flex';
        sidebarTitle.textContent = '📚 통합 이론 학습';
        quizMenu.style.display = 'none';
        theoryMenu.style.display = 'block';
        sidebar.classList.add('open');
        overlay.classList.add('show');
    } else if (tabName === 'progress') {
        document.getElementById('progress-layout').style.display = 'flex';
        // 학습관리 탭에서는 사이드바를 닫습니다.
        closeSidebar(); 
    }
}


/* ===== (신규) 06-12-6. 메인 콘텐츠 마스터 템플릿 함수 ===== */
// 이 함수는 앱의 기본 레이아웃(문제풀이, 이론, 학습관리) HTML을 반환합니다.
// 결과 화면 등에서 메인 화면으로 돌아올 때 이 템플릿을 사용해 뼈대를 다시 그립니다.
function getMainContentHTML() {
    return `
        <!-- 05-1. 문제풀이 화면 레이아웃 시작 -->
        <div class="quiz-layout" id="quiz-layout">
            <div class="main-column">
                <section class="quiz-section" id="quiz-section">
                    <canvas class="annotation-canvas" id="annotation-canvas"></canvas>
                    <div class="quiz-header">
                        <span id="question-counter">문제 준비중</span>
                        <span id="quiz-status">대기</span>
                    </div>
                    <div class="question-container" id="question-container">
                        <h3 id="question-text">목차에서 원하는 과목과 단원을 선택해주세요.</h3>
                        <div class="options-container" id="options-container"></div>
                    </div>
                </section>
                <div class="resizer-vertical" id="vertical-resizer"></div>
                <section class="workspace-section-new" id="workspace-section">
                    <div class="workspace-header">
                        <h3>✏️ 연습장 (문제별 자동저장)</h3>
                        <button class="draw-btn" onclick="clearAllCanvases()">전체 필기 지우기</button>
                    </div>
                    <canvas class="workspace-canvas" id="workspace-canvas"></canvas>
                </section>
            </div>
            <section class="calculator-section">
                <!-- 계산기 HTML 코드는 길어서 생략합니다. 실제 코드에서는 이 부분이 포함됩니다. -->
                <div class="calculator-container">
                    <div class="calc-brand">CASIO JS-40B</div>
                    <div class="calculator-display" id="calc-display">
                        <div class="memory-indicator" id="memory-indicator"></div>
                        <div class="display-value" id="display-value">0</div>
                    </div>
                    <div class="calculator-buttons">
                        <button class="calc-btn memory" onclick="memoryExchange()">M/EX</button><button class="calc-btn function" onclick="percentage()">%</button><button class="calc-btn function" onclick="squareRoot()">√</button><button class="calc-btn function" onclick="backspace()">⌫</button><button class="calc-btn memory" onclick="grandTotal()">GT</button>
                        <button class="calc-btn memory" onclick="memoryClear()">MC</button><button class="calc-btn memory" onclick="memoryRecall()">MR</button><button class="calc-btn memory" onclick="memorySubtract()">M-</button><button class="calc-btn memory" onclick="memoryAdd()">M+</button><button class="calc-btn operator" onclick="appendToDisplay('/')">÷</button>
                        <button class="calc-btn function" onclick="changeSign()">+/-</button><button class="calc-btn number" onclick="appendToDisplay('7')">7</button><button class="calc-btn number" onclick="appendToDisplay('8')">8</button><button class="calc-btn number" onclick="appendToDisplay('9')">9</button><button class="calc-btn operator" onclick="appendToDisplay('*')">×</button>
                        <button class="calc-btn function" onclick="clearEntry()">C</button><button class="calc-btn number" onclick="appendToDisplay('4')">4</button><button class="calc-btn number" onclick="appendToDisplay('5')">5</button><button class="calc-btn number" onclick="appendToDisplay('6')">6</button><button class="calc-btn operator" onclick="appendToDisplay('-')">-</button>
                        <button class="calc-btn function" onclick="clearAll()">AC</button><button class="calc-btn number" onclick="appendToDisplay('1')">1</button><button class="calc-btn number" onclick="appendToDisplay('2')">2</button><button class="calc-btn number" onclick="appendToDisplay('3')">3</button><button class="calc-btn plus-tall" onclick="appendToDisplay('+')">+</button>
                        <button class="calc-btn number" onclick="appendToDisplay('0')">0</button><button class="calc-btn number" onclick="appendToDisplay('00')">00</button><button class="calc-btn number" onclick="appendToDisplay('.')">.</button><button class="calc-btn equals" onclick="calculate()">=</button>
                    </div>
                    <div class="calculation-history">
                        <div class="history-title">계산기록 <button class="clear-history-btn" onclick="clearCalculationHistory()">지우기</button></div>
                        <div class="history-values" id="historyValues"></div>
                    </div>
                </div>
            </section>
        </div>
        <!-- 이론학습 화면 레이아웃 -->
        <div class="theory-layout" id="theory-layout">
            <div class="theory-main-content" id="theoryMainContent">
                <div class="loading-spinner" id="theoryLoadingSpinner" style="display: none;"></div>
                <div class="theory-book" id="theoryBook"></div>
            </div>
        </div>
        <!-- 학습관리 화면 레이아웃 -->
        <div id="progress-layout" style="display: none; justify-content: center; align-items: center; height: 100%;">📊 학습관리 기능은 준비 중입니다.</div>
    `;
}


/* ===== 06-12. 기타 UI 함수들 끝 ===== */


/* ===== 06-13. 타이머 기능 함수들 시작 ===== */
let timerInterval = null;
let timerSeconds = 0;
let timerRunning = false;

function startTimer() {
    if (!timerRunning) {
        timerRunning = true;
        timerInterval = setInterval(() => {
            timerSeconds++;
            updateTimerDisplay();
        }, 1000);
        document.getElementById('start-timer-btn').disabled = true;
        document.getElementById('pause-timer-btn').disabled = false;
    }
}

function pauseTimer() {
    if (timerRunning) {
        timerRunning = false;
        clearInterval(timerInterval);
        document.getElementById('start-timer-btn').disabled = false;
        document.getElementById('pause-timer-btn').disabled = true;
    }
}

function resetTimer() {
    timerRunning = false;
    timerSeconds = 0;
    clearInterval(timerInterval);
    updateTimerDisplay();
    document.getElementById('start-timer-btn').disabled = false;
    document.getElementById('pause-timer-btn').disabled = true;
}

function updateTimerDisplay() {
    const hours = Math.floor(timerSeconds / 3600);
    const minutes = Math.floor((timerSeconds % 3600) / 60);
    const seconds = timerSeconds % 60;
    const timeString = 
        String(hours).padStart(2, '0') + ':' +
        String(minutes).padStart(2, '0') + ':' +
        String(seconds).padStart(2, '0');
    const timerElement = document.getElementById('timer');
    if (timerElement) {
        timerElement.textContent = timeString;
    }
}

function autoStartTimer() {
    if (!timerRunning && timerSeconds === 0) {
        startTimer();
    }
}
/* ===== 06-13. 타이머 기능 함수들 끝 ===== */


/* ===== 06-14. Back4App 연동 및 퀴즈 데이터 관리 시작 ===== */

async function loadTheoryContentFromBack4App(subject, chapter) {
    console.log(`🔍 Back4App 이론 쿼리: 과목=<span class="math-inline">\{subject\}, 챕터\=</span>{chapter}`);
    const TheoryContent = Parse.Object.extend("TheoryContent");
    const query = new Parse.Query(TheoryContent);

    try {
        query.equalTo("subject", subject); // 06-14-3-1. (유지) 과목명(subject)은 항상 일치해야 함
        query.equalTo("isActive", true);

        // 06-14-3-2. (수정) '전체 이론'일 경우 챕터 필터링을 건너뛰는 로직 추가
        if (chapter !== '전체 이론') {
            query.equalTo("chapter", chapter);
        }

        // 06-14-3-3. (수정) 새로 추가한 chapterNumber를 기준으로 정렬
        query.ascending("chapterNumber", "pageGroup", "order");
        query.limit(1000);

        const results = await query.find();
        console.log(`📊 ${results.length}개의 이론 콘텐츠(페이지)를 서버에서 가져옴`);

        if (results.length === 0) return [];

        return results.map(result => ({
            pageGroup: result.get("pageGroup"),
            content: result.get("content")
        }));
    } catch (error) {
        console.error("❌ Back4App 이론 쿼리 실패:", error);
        return [];
    }
}

// 06-14-2. Back4App에서 문제 데이터 로딩 함수 (정리된 버전)
async function loadQuestionsFromBack4App(subject, chapter, originalSubject) {
    console.log(`🔍 Back4App 쿼리: 과목=${subject}, 챕터=${chapter}, 원본=${originalSubject}`);
    const QuestionBank = Parse.Object.extend("QuestionBank");
    const query = new Parse.Query(QuestionBank);

    try {
        const subjectMapping = {
            '재무회계': '회계학개론', '원가관리회계': '회계학개론', '법인세법': '세법학개론',
            '소득세법': '세법학개론', '부가가치세법': '세법학개론', '국세기본법': '세법학개론',
            '국세징수법': '세법학개론', '조세범처벌법': '세법학개론'
        };
        const mappedSubject = subjectMapping[originalSubject] || subject;
        query.equalTo("subject", mappedSubject);
        query.equalTo("isActive", true);

        const subTopics = ['재무회계', '원가관리회계', '법인세법', '소득세법', '부가가치세법', '국세기본법', '국세징수법', '조세범처벌법'];
        if (subTopics.includes(originalSubject)) {
            query.equalTo("topic", originalSubject);
        }

        if (chapter && chapter.includes('년기출')) {
            const year = parseInt(chapter.replace('년기출', ''));
            if (!isNaN(year)) query.equalTo("year", year);
        } else if (chapter && chapter !== 'AI추천' && !chapter.includes('기출문제')) {
            query.startsWith("chapter", chapter);
        }

        query.ascending("questionNumber");
        query.limit(100);

        const results = await query.find();
        console.log(`📊 ${results.length}개의 문제를 서버에서 가져옴`);

        if (results.length === 0) return [];
        return results.map(result => ({
            questionId: result.id,
            subject: result.get("subject"),
            topic: result.get("topic"),
            chapter: result.get("chapter"),
            year: result.get("year"),
            questionNumber: result.get("questionNumber"),
            examType: result.get("examType"),
            questionText: result.get("questionText"),
            options: [result.get('option1'), result.get('option2'), result.get('option3'), result.get('option4'), result.get('option5')].filter(Boolean),
            correctAnswer: result.get("correctAnswer"),
            explanations: {
                'option1': result.get('explanation1'), 'option2': result.get('explanation2'),
                'option3': result.get('explanation3'), 'option4': result.get('explanation4'),
                'option5': result.get('explanation5')
            },
            analystComment: result.get('analystComment')
        }));
    } catch (error) {
        console.error("❌ Back4App 쿼리 실패:", error);
        return [];
    }
}
/* ===== 06-14. Back4App 연동 및 퀴즈 데이터 관리 끝 ===== */


/* ===== 06-15. 퀴즈 실행 및 상호작용 (통합된 단일 버전) 시작 ===== */

// 06-15-1. 한 문제의 내용을 화면에 표시하는 함수
function loadQuestion(questionData) {
    if (!questionData) return;
    
    currentQuestionData = questionData; 

    const questionTextEl = document.getElementById('question-text');
    const optionsContainer = document.getElementById('options-container');

    // 문제 내용 표시
    questionTextEl.innerHTML = `
        <div class="question-header">
            <span class="question-meta">${questionData.subject} | ${questionData.year}년 | ${questionData.examType} | 문제 ${questionData.questionNumber}번</span>
        </div>
        <div class="question-content">${questionData.questionText}</div>`;
    
    // 선택지 표시
    optionsContainer.innerHTML = '';
    let options = questionData.options || [questionData.option1, questionData.option2, questionData.option3, questionData.option4, questionData.option5].filter(Boolean);

    options.forEach((option, index) => {
        const optionDiv = document.createElement('div');
        optionDiv.className = 'option-item';
        
        // [오류 수정] 'question' -> 'questionData'로 변수명을 올바르게 수정하여 클릭 이벤트를 복구합니다.
        optionDiv.onclick = () => selectOption(questionData.questionId, index + 1);
        
        // [오류 수정] 'question' -> 'questionData'로 변수명을 올바르게 수정하여 이전에 선택한 답을 정확히 표시합니다.
        if (selectedAnswers[questionData.questionId] === (index + 1)) {
            optionDiv.classList.add('selected');
        }

        optionDiv.innerHTML = `<span class="option-number">${index + 1}</span><span class="option-text">${option}</span>`;
        optionsContainer.appendChild(optionDiv);
    });

    // 문제 이동 및 풀이 완료 버튼 표시
    const navDiv = document.createElement('div');
    navDiv.className = 'question-navigation';
    navDiv.innerHTML = `
        <button class="nav-btn" onclick="previousQuestion()" ${currentQuestionIndex === 0 ? 'disabled' : ''}>← 이전</button>
        <button class="nav-btn" onclick="nextQuestion()" ${currentQuestionIndex === currentQuestionSet.length - 1 ? 'disabled' : ''}>다음 →</button>
        <button class="nav-btn finish-btn" onclick="finishQuiz()">풀이완료</button>`;
    optionsContainer.appendChild(navDiv);

    // 문제에 맞는 필기 상태를 불러옵니다.
    loadWorkspaceState(currentQuestionIndex);
    loadAnnotationState(currentQuestionIndex);

    if (currentQuestionIndex === 0 && !quizCompleted) {
        autoStartTimer();
    }
}

// 06-15-2. 선택지 선택 처리 함수
function selectOption(questionId, optionNumber) {
    if (quizCompleted) return;
    document.querySelectorAll('.option-item').forEach(item => item.classList.remove('selected'));
    document.querySelectorAll('.option-item')[optionNumber - 1].classList.add('selected');
    selectedAnswers[questionId] = optionNumber;
}

// 06-15-3. 이전/다음 문제 이동 함수
function previousQuestion() {
    if (currentQuestionIndex > 0) {
        saveWorkspaceState(currentQuestionIndex);
        saveAnnotationState(currentQuestionIndex); // (추가) 주석 상태 저장
        currentQuestionIndex--;
        loadQuestion(currentQuestionSet[currentQuestionIndex]);
        updateQuestionCounter();
    }
}

function nextQuestion() {
    if (currentQuestionIndex < currentQuestionSet.length - 1) {
        saveWorkspaceState(currentQuestionIndex);
        saveAnnotationState(currentQuestionIndex); // (추가) 주석 상태 저장
        currentQuestionIndex++;
        loadQuestion(currentQuestionSet[currentQuestionIndex]);
        updateQuestionCounter();
    }
}

// 06-15-4. 문제 카운터 업데이트
function updateQuestionCounter() {
    const counter = document.getElementById('question-counter');
    if (currentQuestionSet.length > 0) {
        counter.textContent = `문제 ${currentQuestionIndex + 1} / ${currentQuestionSet.length}`;
    }
}
/* ===== 06-15. 퀴즈 실행 및 상호작용 끝 ===== */


/* ===== 06-16. 퀴즈 채점 및 결과 기능 시작 ===== */

// 06-16-1. '풀이완료' 버튼 기능
function finishQuiz() {
    // (핵심 추가) 채점 전, 현재 문제의 필기 내용을 먼저 저장합니다.
    saveWorkspaceState(currentQuestionIndex);
    saveAnnotationState(currentQuestionIndex);

    const unansweredCount = currentQuestionSet.length - Object.keys(selectedAnswers).length;
    if (unansweredCount > 0) {
        if (!confirm(`${unansweredCount}개의 문제를 풀지 않았습니다. 정말 채점하시겠습니까?`)) {
            return;
        }
    }
    pauseTimer();
    userAnswers = { ...selectedAnswers };
    quizCompleted = true;
    showResults();
}

// 06-16-2. 최종 결과 화면 표시
function showResults() {
    currentView = 'results';
    pushToViewHistory({ view: 'results', data: null });
    
    const mainContent = document.querySelector('.main-content');
    
    let correctCount = 0;
    currentQuestionSet.forEach(q => {
        if (q.correctAnswer === userAnswers[q.questionId]) {
            correctCount++;
        }
    });
    const totalCount = currentQuestionSet.length;
    const percentage = totalCount > 0 ? Math.round((correctCount / totalCount) * 100) : 0;

    mainContent.innerHTML = `
        <div class="results-mode">
            <div class="quiz-results">
                <h2>🎯 풀이 완료!</h2>
                <div class="score-summary">
                    <div class="score-circle">
                        <span class="score-number">${correctCount}</span>
                        <span class="score-total">/ ${totalCount}</span>
                    </div>
                    <div class="score-percentage">${percentage}%</div>
                </div>
                <div class="score-details">
                    <span class="correct">정답: ${correctCount}개</span>
                    <span class="incorrect">오답: ${totalCount - correctCount}개</span>
                </div>
            </div>
            <div class="retry-section">
                <button class="retry-btn" onclick="startQuiz()">다시 풀기</button>
                <button class="review-btn" onclick="reviewIncorrect()">틀린 문제만</button>
                <button class="review-btn" onclick="showAllExplanations()">전체 해설 보기</button>
            </div>
            <div class="results-grid" id="results-grid-container"></div>
        </div>
    `;

    const gridContainer = document.getElementById('results-grid-container');
    currentQuestionSet.forEach((question, index) => {
        const isCorrect = question.correctAnswer === userAnswers[question.questionId];
        const gridItem = document.createElement('div');
        
        gridItem.className = `result-grid-item ${isCorrect ? 'correct' : 'incorrect'}`;
        gridItem.textContent = `${question.questionNumber}번`;
        gridItem.onclick = () => showQuestionDetail(index);
        gridContainer.appendChild(gridItem);
    });
}
/* ===== 06-16. 퀴즈 채점 및 결과 기능 끝 ===== */


/* ===== 06-17. 해설 보기 기능 시작 ===== */

// (신규) 06-17-0. 캔버스 이미지에서 마지막 필기 위치를 찾는 도우미 함수
function findLastY(imageData) {
    const data = imageData.data;
    const width = imageData.width;
    // RGBA 4개 채널을 고려하여 마지막 픽셀부터 거꾸로 탐색
    for (let y = imageData.height - 1; y >= 0; y--) {
        for (let x = 0; x < width; x++) {
            // 알파 채널(투명도) 값이 0이 아닌 첫 픽셀을 찾음
            if (data[(y * width + x) * 4 + 3] > 0) {
                return y; // 마지막으로 그려진 픽셀의 Y 좌표 반환
            }
        }
    }
    return 0; // 아무것도 그려지지 않았으면 0 반환
}

// 06-17-1. 개별 문제 상세 해설 표시 (연습장 필기 표시 기능 추가)
function showQuestionDetail(questionIndex) {
    currentView = 'detail';
    pushToViewHistory({ view: 'detail', data: questionIndex });

    const mainContent = document.querySelector('.main-content');
    // ✨ 개별 해설 화면에서는 연습장이 필요 없으므로 quiz-layout을 사용하지 않습니다.
    mainContent.innerHTML = `
        <div class="explanation-mode">
            <div class="explanation-content" id="all-explanations-container">
            </div>
            <section class="calculator-section">
                </section>
        </div>
    `;
    // 계산기 HTML을 동적으로 채우는 코드를 추가하거나, getQuizLayoutHTML을 수정하여 일부만 가져올 수 있습니다.
    // 여기서는 간단하게 설명하기 위해 생략하고, 해설 표시에 집중합니다.
    
    const question = currentQuestionSet[questionIndex];
    const userAnswer = userAnswers[question.questionId];
    const explanationContainer = document.getElementById('all-explanations-container');

    // 문제 기본 정보 구성
    let html = `
        <div class="explanation-header">
            <h2>문제 ${question.questionNumber} 해설</h2>
            <button class="nav-btn" onclick="goBack()">결과 목록으로</button>
        </div>
        <div class="question-content" style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 6px;">
            ${question.questionText}
        </div>
    `;
    explanationContainer.innerHTML = html;

    // (신규) 연습장 필기 내용 표시 로직
    const workspaceDataUrl = workspaceStates[questionIndex];
    if (workspaceDataUrl) {
        const img = new Image();
        img.onload = () => {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            tempCtx.drawImage(img, 0, 0);
            
            const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
            const lastY = findLastY(imageData);

            if (lastY > 0) {
                const cropHeight = lastY + 20; // 하단에 20px 여백 추가
                const cropCanvas = document.createElement('canvas');
                const cropCtx = cropCanvas.getContext('2d');
                cropCanvas.width = img.width;
                cropCanvas.height = cropHeight;
                
                // 배경을 흰색으로 채워서 투명(검은색)으로 보이지 않게 함
                cropCtx.fillStyle = 'white';
                cropCtx.fillRect(0, 0, cropCanvas.width, cropCanvas.height);
                cropCtx.drawImage(tempCanvas, 0, 0, img.width, cropHeight, 0, 0, img.width, cropHeight);

                const snapshotDiv = document.createElement('div');
                snapshotDiv.innerHTML = `
                    <div class="workspace-snapshot-header" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e9ecef;">📝 연습장 필기</div>
                    <img src="${cropCanvas.toDataURL()}" class="workspace-snapshot" style="background: white;">
                `;
                explanationContainer.appendChild(snapshotDiv);
            }
        };
        img.src = workspaceDataUrl;
    }

    // 기존 해설 표시 로직
    question.options.forEach((option, index) => {
        const optionNumber = index + 1;
        const explanation = question.explanations[`option${optionNumber}`] || '해설이 준비되지 않았습니다.';
        const isCorrectOption = optionNumber === question.correctAnswer;
        const isUserChoice = optionNumber === userAnswer;
        
        const explanationDiv = document.createElement('div');
        explanationDiv.className = `explanation-item ${isCorrectOption ? 'correct' : 'incorrect'} ${isUserChoice ? 'user-choice' : ''}`;
        explanationDiv.innerHTML = `<div class="option-header"><span class="option-number">${optionNumber}</span><span class="option-text" style="flex: 1;">${option}</span><span class="option-status">${isCorrectOption ? '✓' : '✗'} ${isUserChoice ? '(내 답안)' : ''}</span></div><div class="explanation-text"><strong>해설:</strong> ${explanation}</div>`;
        explanationContainer.appendChild(explanationDiv);
    });
}

// 06-17-2. 전체 해설 모드 표시
function showAllExplanations() {
    currentView = 'allExplanations';
    pushToViewHistory({ view: 'allExplanations', data: null });
    
    const mainContent = document.querySelector('.main-content');
    
    mainContent.innerHTML = `
        <div class="explanation-mode">
            <div class="explanation-content" id="all-explanations-container">
                <div class="explanation-header">
                    <h2>📋 전체 문제 해설</h2>
                    <div class="explanation-controls">
                        <button class="nav-btn" onclick="goBack()">결과 화면으로 돌아가기</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    const container = document.getElementById('all-explanations-container');
    if (!currentQuestionSet || currentQuestionSet.length === 0) {
        container.innerHTML += '<p>표시할 문제가 없습니다.</p>';
        return;
    }

    currentQuestionSet.forEach((question, index) => {
        const userAnswer = userAnswers[question.questionId];
        const isCorrect = userAnswer === question.correctAnswer;
        
        const questionDiv = document.createElement('div');
        if (index > 0) questionDiv.className = 'question-divider';
        
        questionDiv.innerHTML = `
            <div class="question-summary">
                <strong>문제 ${question.questionNumber}번</strong>
                <span class="question-result ${isCorrect ? 'correct' : 'incorrect'}">${isCorrect ? '정답' : '오답'}</span>
                <div style="margin-top: 8px; font-size: 14px; color: #6c757d;">
                    정답: ${question.correctAnswer}번 | 선택: ${userAnswer ? userAnswer + '번' : '미선택'}
                </div>
            </div>
            <div class="question-content" style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                ${question.questionText}
            </div>
        `;
        
        if (question.options && question.explanations) {
            question.options.forEach((option, optionIndex) => {
                const optionNumber = optionIndex + 1;
                const explanation = question.explanations[`option${optionNumber}`] || '해설이 준비되지 않았습니다.';
                
                const explanationDiv = document.createElement('div');
                explanationDiv.className = `explanation-item ${optionNumber === question.correctAnswer ? 'correct' : 'incorrect'}`;
                explanationDiv.innerHTML = `
                    <div class="option-header">
                        <span class="option-number">${optionNumber}</span>
                        <span style="flex: 1;">${option}</span>
                        <span class="option-status">${optionNumber === question.correctAnswer ? '✅' : '❌'}</span>
                    </div>
                    <div class="explanation-text">${explanation}</div>`;
                questionDiv.appendChild(explanationDiv);
            });
        }
        container.appendChild(questionDiv);
    });
}
/* ===== 06-17. 해설 보기 기능 끝 ===== */


/* ===== 06-18. 다시 풀기 기능 시작 ===== */

// 06-18-1. 현재 퀴즈 다시 풀기
function startQuiz() {
    if (!confirm("현재 퀴즈를 처음부터 다시 푸시겠습니까?")) return;
    
    const firstQuestionInfo = viewHistory.find(h => h.view === 'quiz');
    if (firstQuestionInfo) {
        selectChapter(firstQuestionInfo.data.subject, firstQuestionInfo.data.chapter);
    }
}

// 06-18-2. 틀린 문제만 다시 풀기
function reviewIncorrect() {
    const incorrectQuestions = currentQuestionSet.filter(q => q.correctAnswer !== userAnswers[q.questionId]);
    if (incorrectQuestions.length === 0) {
        alert('🎉 틀린 문제가 없습니다!');
        return;
    }
    
    const mainContent = document.querySelector('.main-content');
    mainContent.innerHTML = `
        <div class="quiz-layout" id="quiz-layout">
            <section class="quiz-section">
                <div class="quiz-header"><span id="question-counter"></span><span id="quiz-status"></span></div>
                <div class="question-container" id="question-container"><h3 id="question-text"></h3><div class="options-container" id="options-container"></div></div>
            </section>
            <section class="calculator-section">
                <div class="calculator-container"><div class="calc-brand">CASIO JS-40B</div><div class="calculator-display" id="calc-display"><div class="memory-indicator" id="memory-indicator"></div><div class="display-value" id="display-value">0</div></div><div class="calculator-buttons"><button class="calc-btn memory" onclick="memoryExchange()">M/EX</button><button class="calc-btn function" onclick="percentage()">%</button><button class="calc-btn function" onclick="squareRoot()">√</button><button class="calc-btn function" onclick="backspace()">⌫</button><button class="calc-btn memory" onclick="grandTotal()">GT</button><button class="calc-btn memory" onclick="memoryClear()">MC</button><button class="calc-btn memory" onclick="memoryRecall()">MR</button><button class="calc-btn memory" onclick="memorySubtract()">M-</button><button class="calc-btn memory" onclick="memoryAdd()">M+</button><button class="calc-btn operator" onclick="appendToDisplay('/')">÷</button><button class="calc-btn function" onclick="changeSign()">+/-</button><button class="calc-btn number" onclick="appendToDisplay('7')">7</button><button class="calc-btn number" onclick="appendToDisplay('8')">8</button><button class="calc-btn number" onclick="appendToDisplay('9')">9</button><button class="calc-btn operator" onclick="appendToDisplay('*')">×</button><button class="calc-btn function" onclick="clearEntry()">C</button><button class="calc-btn number" onclick="appendToDisplay('4')">4</button><button class="calc-btn number" onclick="appendToDisplay('5')">5</button><button class="calc-btn number" onclick="appendToDisplay('6')">6</button><button class="calc-btn operator" onclick="appendToDisplay('-')">-</button><button class="calc-btn function" onclick="clearAll()">AC</button><button class="calc-btn number" onclick="appendToDisplay('1')">1</button><button class="calc-btn number" onclick="appendToDisplay('2')">2</button><button class="calc-btn number" onclick="appendToDisplay('3')">3</button><button class="calc-btn plus-tall" onclick="appendToDisplay('+')">+</button><button class="calc-btn number" onclick="appendToDisplay('0')">0</button><button class="calc-btn number" onclick="appendToDisplay('00')">00</button><button class="calc-btn number" onclick="appendToDisplay('.')">.</button><button class="calc-btn equals" onclick="calculate()">=</button></div><div class="calculation-history"><div class="history-title">계산기록<button class="clear-history-btn" onclick="clearCalculationHistory()">지우기</button></div><div class="history-values" id="historyValues"></div></div></div>
            </section>
        </div>
    `;

    resetQuizState();
    currentQuestionSet = incorrectQuestions;
    
    pushToViewHistory({
        view: 'quiz',
        data: { subject: '틀린 문제', chapter: '다시 풀기' }
    });

    loadQuestion(currentQuestionSet[0]);
    updateQuestionCounter();
}
/* ===== 06-18. 다시 풀기 기능 끝 ===== */


/* ===== 06-19. 초기화 함수 시작 ===== */
document.addEventListener('DOMContentLoaded', function() {
    Parse.initialize("sRKpx71t2JwbatmvWe2SZi67cShfsk72HhyR1vqb", "fG2HXOiMWSlHuSmeOINADUyNU8rPxX5lku389GJV");
    Parse.serverURL = "https://parseapi.back4app.com/";
    
    testBack4AppConnection();
    goHome(); // goHome 함수가 UI 생성과 기능 초기화를 모두 담당합니다.
});

async function testBack4AppConnection() {
    try {
        await Parse.Cloud.run('health');
        console.log("✅ Back4App 연결 성공!");
        // goHome 함수가 호출되므로 아래 라인은 없어도 됩니다.
    } catch (error) {
        console.error("❌ Back4App 연결 실패:", error);
        document.getElementById('question-text').textContent = "Back4App 서버 연결에 실패했습니다. 인터넷 연결을 확인해주세요.";
    }
}

document.addEventListener('dblclick', function(e) {
    e.preventDefault();
}, { passive: false });
/* ===== 06-19. 초기화 함수 끝 ===== */

/* ===== 06-20. 스마트 캔버스 및 UI 기능 (최종 완성본) 시작 ===== */

// 06-20-1. 캔버스 및 리사이저 초기화 메인 함수
function setupQuizInterface() {
    initializeCanvases();
    initializeVerticalResizer();
}

// 06-20-2. (전면 교체) 캔버스 초기화 (리사이즈 필기 삭제 최종 해결)
function initializeCanvases() {
    const quizSection = document.getElementById('quiz-section');
    const workspaceSection = document.getElementById('workspace-section');
    annotationCanvas = document.getElementById('annotation-canvas');
    workspaceCanvas = document.getElementById('workspace-canvas');

    if (!quizSection || !workspaceSection || !annotationCanvas || !workspaceCanvas) return;

    if (window.canvasResizeObserver) window.canvasResizeObserver.disconnect();
    
    window.canvasResizeObserver = new ResizeObserver(entries => {
        for (const entry of entries) {
            const container = entry.target;
            const canvas = container.querySelector('canvas');
            if (!canvas) continue;

            const ctx = canvas.getContext('2d');
            
            let oldDrawing = null;
            if (canvas.width > 0 && canvas.height > 0) {
                oldDrawing = ctx.getImageData(0, 0, canvas.width, canvas.height);
            }

            let newWidth, newHeight;

            if (container.id === 'quiz-section') {
                // (최종 핵심 수정) contentRect(여백제외) 대신, 여백을 포함하는 clientWidth/clientHeight를 사용합니다.
                // 이것이 '지우개 현상'과 '필기 안 되는 영역' 문제의 진짜 원인이었습니다.
                newWidth = container.clientWidth;
                newHeight = container.clientHeight;
            } else { // workspace-section
                // 연습장은 보이는 너비(clientWidth)와 고정된 높이를 사용합니다.
                newWidth = canvas.clientWidth;
                newHeight = 1000;
            }

            if (newWidth <= 0) continue;
            if (canvas.id === 'annotation-canvas' && newHeight <= 0) continue;
            
            // 캔버스의 실제 해상도(width/height 속성)가 보이는 크기와 다를 때만 업데이트합니다.
            if (canvas.width !== newWidth || canvas.height !== newHeight) {
                canvas.width = newWidth;
                canvas.height = newHeight;

                // 저장해둔 그림이 있으면, 새 캔버스에 즉시 다시 그려줍니다.
                if (oldDrawing) {
                    ctx.putImageData(oldDrawing, 0, 0);
                }
            }
        }
    });

    // 두 컨테이너 모두 크기 변경 감시
    window.canvasResizeObserver.observe(quizSection);
    window.canvasResizeObserver.observe(workspaceSection);

    // --- 이하 이벤트 리스너 설정은 기존과 동일 ---
    [annotationCanvas, workspaceCanvas].forEach(canvas => {
        if (canvas) {
            canvas.removeEventListener('pointerdown', handlePointerDown);
            canvas.addEventListener('pointerdown', handlePointerDown);
        }
    });

    annotationCtx = annotationCanvas.getContext('2d');
    workspaceCtx = workspaceCanvas.getContext('2d');
    
    document.removeEventListener('pointermove', handlePointerMove);
    document.addEventListener('pointermove', handlePointerMove);
    document.removeEventListener('pointerup', handlePointerUp);
    document.addEventListener('pointerup', handlePointerUp);
}

// 06-20-3. 포인터 '누름' 이벤트 핸들러 (단순화)
function handlePointerDown(e) {
    // CSS에서 스크롤바 영역을 제외했으므로, 이 이벤트는 캔버스 위에서만 발생합니다.
    if (e.target.tagName !== 'CANVAS') return;

    // 오른쪽 클릭 무시
    if (e.button === 2) return;
    
    isPointerDown = true;
    isDragging = false;
    pointerDownTime = Date.now();
    startCoords = { x: e.clientX, y: e.clientY };
    lastCanvasCoords = { x: e.offsetX, y: e.offsetY };
    
    // 텍스트 선택 같은 기본 동작을 막아 필기/탭 기능이 원활하게 작동하도록 합니다.
    e.preventDefault();
}

// 06-20-4. 포인터 '이동' 이벤트 핸들러 (지우개 및 색상 변경 로직 포함)
function handlePointerMove(e) {
    if (!isPointerDown) return;
    if (!isDragging) {
        const distance = Math.sqrt(Math.pow(e.clientX - startCoords.x, 2) + Math.pow(e.clientY - startCoords.y, 2));
        if (distance > DRAG_THRESHOLD_PX) isDragging = true;
    }

    if (isDragging) {
        // e.target이 캔버스가 아닌 경우(캔버스 밖으로 드래그)를 대비해 활성 캔버스를 추적해야 하지만,
        // 현재는 e.target이 캔버스인 경우에만 그리도록 단순화합니다.
        const currentCanvas = e.target;
        if (currentCanvas && currentCanvas.tagName === 'CANVAS') {
            const ctx = currentCanvas.getContext('2d');
            ctx.beginPath();
            ctx.moveTo(lastCanvasCoords.x, lastCanvasCoords.y);
            ctx.lineTo(e.offsetX, e.offsetY);

            // 지우개 모드와 그리기 모드 분기
            if (isEraserMode) {
                ctx.globalCompositeOperation = 'destination-out'; // 지우개 모드
                ctx.lineWidth = 20; // 지우개 크기
            } else {
                ctx.globalCompositeOperation = 'source-over'; // 그리기 모드
                ctx.strokeStyle = '#000000'; // 필기 색상 검은색
                ctx.lineWidth = 2.5; // 펜 굵기
            }
            ctx.lineCap = 'round';
            ctx.stroke();
            lastCanvasCoords = { x: e.offsetX, y: e.offsetY };
        }
    }
}

// 06-20-5. 포인터 '뗌' 이벤트 핸들러
function handlePointerUp(e) {
    if (!isPointerDown) return;
    isPointerDown = false;
    const duration = Date.now() - pointerDownTime;
    if (!isDragging && duration < TAP_THRESHOLD_MS) handleTap(e);
    isDragging = false;
}

// 06-20-6. '탭' 동작 처리 함수
function handleTap(e) {
    const tappedCanvas = e.target;
    if (!tappedCanvas || tappedCanvas.tagName !== 'CANVAS') return;
    tappedCanvas.style.pointerEvents = 'none';
    const elementBeneath = document.elementFromPoint(e.clientX, e.clientY);
    tappedCanvas.style.pointerEvents = 'auto';
    if (elementBeneath && typeof elementBeneath.click === 'function') {
        elementBeneath.click();
    }
}

// 06-20-7. 지우개 모드 토글 함수
function toggleEraserMode() {
    isEraserMode = !isEraserMode;
    const btn = document.getElementById('eraser-btn');
    if (btn) {
        if (isEraserMode) {
            btn.style.background = '#007bff';
            btn.style.color = 'white';
        } else {
            btn.style.background = '';
            btn.style.color = '';
        }
    }
}

// 06-20-8. 모든 캔버스 필기 지우기
function clearAllCanvases() {
    if (confirm('문제와 연습장의 모든 필기를 지우시겠습니까?')) {
        if (workspaceCtx) workspaceCtx.clearRect(0, 0, workspaceCanvas.width, workspaceCanvas.height);
        if (annotationCtx) annotationCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
    }
}

// 06-20-9. 문제별 상태 저장/복원 함수 (생략 없이 모두 포함)
function saveWorkspaceState(index) {
    if (workspaceCanvas) workspaceStates[index] = workspaceCanvas.toDataURL();
}
function saveAnnotationState(index) {
    if (annotationCanvas) annotationStates[index] = annotationCanvas.toDataURL();
}
function loadWorkspaceState(index) {
    if (workspaceCtx) workspaceCtx.clearRect(0, 0, workspaceCanvas.width, workspaceCanvas.height);
    if (workspaceCanvas && workspaceStates[index]) {
        const img = new Image();
        img.onload = () => { if (workspaceCtx) workspaceCtx.drawImage(img, 0, 0); };
        img.src = workspaceStates[index];
    }
}
function loadAnnotationState(index) {
    if (annotationCtx) annotationCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
    if (annotationCanvas && annotationStates[index]) {
        const img = new Image();
        img.onload = () => { if (annotationCtx) annotationCtx.drawImage(img, 0, 0); };
        img.src = annotationStates[index];
    }
}


// 06-20-10. 수직 리사이저 초기화 (양쪽 영역 높이 동시 조절 최종본)
function initializeVerticalResizer() {
    const resizer = document.getElementById('vertical-resizer');
    const mainColumn = document.querySelector('.main-column');
    const quizSection = document.getElementById('quiz-section');
    const workspaceSection = document.getElementById('workspace-section');

    if (!resizer || !mainColumn || !quizSection || !workspaceSection) return;

    let isResizing = false;

    const startResizing = (e) => {
        isResizing = true;
        document.body.style.cursor = 'row-resize';
        document.body.style.userSelect = 'none';
        e.preventDefault();
    };

    const doResize = (e) => {
        if (!isResizing) return;
        
        const mainRect = mainColumn.getBoundingClientRect();
        if (mainRect.height === 0) return;

        const resizerHeight = resizer.offsetHeight;
        const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
        if (clientY === 0) return;

        let newQuizHeight = clientY - mainRect.top;
        let newWorkspaceHeight = mainRect.height - newQuizHeight - resizerHeight;

        const minHeight = 80;
        if (newQuizHeight < minHeight) {
            newQuizHeight = minHeight;
            newWorkspaceHeight = mainRect.height - newQuizHeight - resizerHeight;
        }
        if (newWorkspaceHeight < minHeight) {
            newWorkspaceHeight = minHeight;
            newQuizHeight = mainRect.height - newWorkspaceHeight - resizerHeight;
        }

        quizSection.style.flex = 'none';
        workspaceSection.style.flex = 'none';

        quizSection.style.height = `${newQuizHeight}px`;
        workspaceSection.style.height = `${newWorkspaceHeight}px`;
    };

    const stopResizing = () => {
        if (isResizing) {
            isResizing = false;
            document.body.style.cursor = 'default';
            document.body.style.userSelect = 'auto';
        }
    };

    resizer.addEventListener('mousedown', startResizing);
    document.addEventListener('mousemove', doResize);
    document.addEventListener('mouseup', stopResizing);
    resizer.addEventListener('touchstart', startResizing, { passive: false });
    document.addEventListener('touchmove', doResize);
    document.addEventListener('touchend', stopResizing);
}

/* ===== 06-20. 스마트 캔버스 및 UI 기능 (최종 완성본) 끝 ===== */

/* ===== 06-21. UI 템플릿 함수 시작 ===== */

// 06-21-1. 메인 콘텐츠 전체 레이아웃 HTML 생성 함수 (수정)
function getMainContentHTML() {
    // 퀴즈, 이론, 학습관리 레이아웃을 모두 포함하는 전체 HTML 구조를 반환합니다.
    return `
        <div class="quiz-layout" id="quiz-layout">
            <div class="main-column">
                <section class="quiz-section" id="quiz-section">
                    <canvas class="annotation-canvas" id="annotation-canvas"></canvas>
                    <div class="quiz-header">
                        <span id="question-counter">문제 준비중</span><span id="quiz-status">대기</span>
                    </div>
                    <div class="question-container" id="question-container">
                        <h3 id="question-text">목차에서 원하는 과목과 단원을 선택해주세요.</h3>
                        <div class="options-container" id="options-container"></div>
                    </div>
                </section>
                <div class="resizer-vertical" id="vertical-resizer"></div>
                <section class="workspace-section-new" id="workspace-section">
                    <div class="workspace-header">
                        <h3>✏️ 연습장</h3>
                        <div>
                            <button class="draw-btn" id="eraser-btn" onclick="toggleEraserMode()">지우개</button>
                            <button class="draw-btn" onclick="clearAllCanvases()">전체 지우기</button>
                        </div>
                    </div>
                    <canvas class="workspace-canvas" id="workspace-canvas"></canvas>
                </section>
            </div>
            <section class="calculator-section">
                <div class="calculator-container">
                    <div class="calc-brand">CASIO JS-40B</div>
                    <div class="calculator-display" id="calc-display">
                        <div class="memory-indicator" id="memory-indicator"></div>
                        <div class="display-value" id="display-value">0</div>
                    </div>
                    <div class="calculator-buttons">
                        <button class="calc-btn memory" onclick="memoryExchange()">M/EX</button><button class="calc-btn function" onclick="percentage()">%</button><button class="calc-btn function" onclick="squareRoot()">√</button><button class="calc-btn function" onclick="backspace()">⌫</button><button class="calc-btn memory" onclick="grandTotal()">GT</button><button class="calc-btn memory" onclick="memoryClear()">MC</button><button class="calc-btn memory" onclick="memoryRecall()">MR</button><button class="calc-btn memory" onclick="memorySubtract()">M-</button><button class="calc-btn memory" onclick="memoryAdd()">M+</button><button class="calc-btn operator" onclick="appendToDisplay('/')">÷</button><button class="calc-btn function" onclick="changeSign()">+/-</button><button class="calc-btn number" onclick="appendToDisplay('7')">7</button><button class="calc-btn number" onclick="appendToDisplay('8')">8</button><button class="calc-btn number" onclick="appendToDisplay('9')">9</button><button class="calc-btn operator" onclick="appendToDisplay('*')">×</button><button class="calc-btn function" onclick="clearEntry()">C</button><button class="calc-btn number" onclick="appendToDisplay('4')">4</button><button class="calc-btn number" onclick="appendToDisplay('5')">5</button><button class="calc-btn number" onclick="appendToDisplay('6')">6</button><button class="calc-btn operator" onclick="appendToDisplay('-')">-</button><button class="calc-btn function" onclick="clearAll()">AC</button><button class="calc-btn number" onclick="appendToDisplay('1')">1</button><button class="calc-btn number" onclick="appendToDisplay('2')">2</button><button class="calc-btn number" onclick="appendToDisplay('3')">3</button><button class="calc-btn plus-tall" onclick="appendToDisplay('+')">+</button><button class="calc-btn number" onclick="appendToDisplay('0')">0</button><button class="calc-btn number" onclick="appendToDisplay('00')">00</button><button class="calc-btn number" onclick="appendToDisplay('.')">.</button><button class="calc-btn equals" onclick="calculate()">=</button>
                    </div>
                    <div class="calculation-history"><div class="history-title">계산기록<button class="clear-history-btn" onclick="clearCalculationHistory()">지우기</button></div><div class="history-values" id="historyValues"></div></div>
                </div>
            </section>
        </div>

        <div class="theory-layout" id="theory-layout">
            <main class="theory-main-content" id="theoryMainContent">
                <div id="theoryLoadingSpinner">📚 이론 데이터베이스에 접속하는 중...</div>
                <div class="theory-book" id="theoryBook" style="display:none;"></div>
            </main>
        </div>

        <div id="progress-layout" style="display: none; justify-content: center; align-items: center; font-size: 1.2em; color: #6c757d; height: 100%;">
            📊 학습관리 기능은 준비 중입니다.
        </div>
    `;
}

/* ===== 06-21. UI 템플릿 함수 끝 ===== */

// (신규) 06-22. 이론 콘텐츠를 책 형태로 렌더링하는 함수
function renderTheoryBook(contents) {
    const theoryBook = document.getElementById('theoryBook');
    theoryBook.innerHTML = ''; // 기존 내용 초기화

    // pageGroup 번호를 기준으로 콘텐츠 그룹화
    const pagesByGroup = contents.reduce((acc, item) => {
        acc[item.pageGroup] = acc[item.pageGroup] || [];
        acc[item.pageGroup].push(item.content);
        return acc;
    }, {});

    // pageGroup 오름차순으로 정렬된 키 배열 생성
    const sortedGroups = Object.keys(pagesByGroup).sort((a, b) => parseInt(a) - parseInt(b));
    const totalPageSpreads = sortedGroups.length;

    // 각 페이지 그룹(펼친 페이지)을 HTML로 구성
    sortedGroups.forEach((groupKey, index) => {
        const pageContents = pagesByGroup[groupKey];
        
        const pageSpread = document.createElement('div');
        pageSpread.className = 'theory-page-spread';

        const leftPageNumber = index * 2 + 1;
        const rightPageNumber = index * 2 + 2;

        pageSpread.innerHTML = `
            <div class="theory-page theory-left-page">
                <div class="theory-content-wrapper">${pageContents[0] || ''}</div>
                <div class="theory-page-number">${leftPageNumber}</div>
            </div>
            <div class="theory-page theory-right-page">
                <div class="theory-content-wrapper">${pageContents[1] || ''}</div>
                <div class="theory-page-number">${rightPageNumber}</div>
            </div>
        `;
        theoryBook.appendChild(pageSpread);
    });

    // 모든 페이지가 추가된 후, 책의 전체 너비를 설정
    if (totalPageSpreads > 0) {
        theoryBook.style.width = `${totalPageSpreads * 100}%`;
    }
}

/* 더이상 사용하지 않는 기능
// (신규) 06-23. 이론 책 넘김(스와이프) 기능 설정 함수
function setupTheoryBookNavigation() {
    const book = document.getElementById('theoryBook');
    const mainContent = document.getElementById('theoryMainContent');
    if (!book || !mainContent) return;

    let currentPage = 0;
    let startX = 0;
    let isDragging = false;
    let currentTranslateX = 0;

    const pageSpreads = book.querySelectorAll('.theory-page-spread');
    if (pageSpreads.length === 0) return;
    
    const totalPages = pageSpreads.length;
    
    const navigate = (page) => {
        if (page < 0) page = 0;
        if (page >= totalPages) page = totalPages - 1;
        
        currentPage = page;
        const viewWidth = mainContent.clientWidth;
        
           // (핵심 수정) 이동 거리를 계산할 때, 페이지 너비(viewWidth)에
    // CSS에 설정된 오른쪽 여백(40px)을 더해줍니다.
    const totalMoveDistance = -currentPage * (viewWidth + 40);
    currentTranslateX = totalMoveDistance;
    
        book.style.transition = 'transform 0.4s ease-in-out';
        book.style.transform = `translateX(${currentTranslateX}px)`;
    };
    
    // 초기 페이지로 이동
    navigate(0);

    const onPointerDown = (e) => {
        isDragging = true;
        startX = e.pageX || e.touches[0].pageX;
        book.style.transition = 'none';
        e.currentTarget.setPointerCapture(e.pointerId); // 포인터 이벤트 독점
    };

    const onPointerMove = (e) => {
        if (!isDragging) return;
        const currentX = e.pageX || e.touches[0].pageX;
        const diffX = currentX - startX;
        book.style.transform = `translateX(${currentTranslateX + diffX}px)`;
    };

    const onPointerUp = (e) => {
        if (!isDragging) return;
        isDragging = false;
        
        e.currentTarget.releasePointerCapture(e.pointerId);

        const endX = e.pageX || e.changedTouches[0].pageX;
        const diffX = endX - startX;
        
        // 스와이프 감지 임계값 (50px 이상 움직여야 페이지 넘김)
        if (Math.abs(diffX) > 50) {
            if (diffX < 0) { // 왼쪽으로 스와이프 (다음 페이지)
                navigate(currentPage + 1);
            } else { // 오른쪽으로 스와이프 (이전 페이지)
                navigate(currentPage - 1);
            }
        } else { // 임계값 미만이면 원래 페이지로 복귀
            navigate(currentPage);
        }
    };
    
    // 리스너 중복 방지를 위해 기존 리스너 제거
    const controller = new AbortController();
    const options = { signal: controller.signal };

    if (book.dataset.eventsAttached) {
        // 기존 컨트롤러가 있다면 이벤트를 중단시킴 (실제로는 복잡하므로 간단히 플래그로만 관리)
    }

    book.addEventListener('pointerdown', onPointerDown, options);
    book.addEventListener('pointermove', onPointerMove, options);
    book.addEventListener('pointerup', onPointerUp, options);
    book.addEventListener('pointercancel', onPointerUp, options);
    book.dataset.eventsAttached = 'true';

    // 창 크기 변경 시 현재 페이지 위치 재조정
    const resizeObserver = new ResizeObserver(() => {
        navigate(currentPage);
    });
    resizeObserver.observe(mainContent);
} */

    </script>
    <!-- 1. Back4App 연동 및 콘텐츠 표시를 위한 메인 스크립트 -->
<script src="https://unpkg.com/parse@4.0.1/dist/parse.min.js"></script>
<script>
    // 2. Back4App 초기화
    // 'YOUR_APP_ID'와 'YOUR_JAVASCRIPT_KEY'는 Back4App 대시보드의 'App Keys'에서 확인하여 실제 값으로 교체해주세요.
    Parse.initialize("sRKpx71t2JwbatmvWe2SZi67cShfsk72HhyR1vqb", "fG2HXOiMWSlHuSmeOINADUyNU8rPxX5lku389GJV");
    Parse.serverURL = "https://parseapi.back4app.com/";

    /* 3. 이론 콘텐츠 조회 및 렌더링 함수 */
    async function fetchAndDisplayTheory(subject, chapter) {
        const contentContainer = document.getElementById('content-container');
        const loadingMessage = document.getElementById('loading-message');

        // 3-1. 로딩 메시지 표시 및 기존 콘텐츠 초기화
        loadingMessage.style.display = 'block'; // 로딩 메시지를 다시 보이게 합니다.
        loadingMessage.textContent = `📚 '${chapter}' 이론 데이터를 불러오는 중...`;
        contentContainer.innerHTML = '';

        const TheoryContent = Parse.Object.extend("TheoryContent");
        const query = new Parse.Query(TheoryContent);

        // 3-2. 조회 조건 설정
        query.equalTo("subject", subject);
        query.equalTo("chapter", chapter);
        query.equalTo("isActive", true);
        query.ascending("pageGroup", "order");

        try {
            const results = await query.find();

            if (results.length === 0) {
                loadingMessage.textContent = '😅 해당 챕터의 학습 데이터가 아직 준비되지 않았습니다.';
                return;
            }

            // 3-3. 'pageGroup' 기준으로 데이터 그룹화
            const pagesByGroup = results.reduce((acc, item) => {
                const group = item.get('pageGroup');
                const content = item.get('content'); // HTML 콘텐츠
                if (!acc[group]) acc[group] = [];
                acc[group].push(content);
                return acc;
            }, {});

            // 3-4. '두 페이지 보기' HTML 생성
            let finalHtml = '';
            for (const group in pagesByGroup) {
                const contents = pagesByGroup[group];
                // 기획서에 따라 h1, h2, h3 태그에 형광펜 효과 스타일을 적용합니다.
                const styledLeftContent = contents[0] ? contents[0].replace(/<h1>/g, '<h1 style="background-color: #dad4ff;">').replace(/<h2>/g, '<h2 style="background-color: #b7e5ff;">').replace(/<h3>/g, '<h3 style="background-color: #D6E8DB;">') : '';
                const styledRightContent = contents[1] ? contents[1].replace(/<h1>/g, '<h1 style="background-color: #dad4ff;">').replace(/<h2>/g, '<h2 style="background-color: #b7e5ff;">').replace(/<h3>/g, '<h3 style="background-color: #D6E8DB;">') : '';

                finalHtml += `
                    <div class="page-spread">
                        <div class="page left">${styledLeftContent}</div>
                        <div class="page right">${styledRightContent}</div>
                    </div>
                `;
            }
            
            contentContainer.innerHTML = finalHtml;
            loadingMessage.style.display = 'none';

        } catch (error) {
            console.error("데이터 조회 중 오류 발생:", error);
            loadingMessage.textContent = '🚫 데이터를 불러오는 데 실패했습니다. 콘솔(F12)을 확인해주세요.';
        }
    }

    /* 4. 모든 목차 링크(a 태그)에 클릭 이벤트 추가 */
    document.querySelectorAll('.sidebar-content a').forEach(link => {
        link.addEventListener('click', (event) => {
            event.preventDefault(); // 기본 링크 이동 방지

            // 4-1. 클릭된 챕터와 상위 과목 정보 가져오기
            const chapterText = event.target.textContent;
            const parentUl = event.target.closest('ul');
            const subjectH3 = parentUl ? parentUl.previousElementSibling : null;
            // '▼' 문자를 제거하고 앞뒤 공백을 정리합니다.
            const subjectText = subjectH3 && subjectH3.tagName === 'H3' ? subjectH3.textContent.replace('▼', '').trim() : '알 수 없는 과목';

            // 4-2. 데이터 조회 함수 호출
            fetchAndDisplayTheory(subjectText, chapterText);
        });
    });
</script>

</body>
</html>